// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: osi_featuredata.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "osi_featuredata.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace osi3 {

namespace {

const ::google::protobuf::Descriptor* FeatureData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FeatureData_reflection_ = NULL;
const ::google::protobuf::Descriptor* SensorDetectionHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SensorDetectionHeader_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SensorDetectionHeader_DataQualifier_descriptor_ = NULL;
const ::google::protobuf::Descriptor* RadarDetectionData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RadarDetectionData_reflection_ = NULL;
const ::google::protobuf::Descriptor* RadarDetection_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RadarDetection_reflection_ = NULL;
const ::google::protobuf::Descriptor* LidarDetectionData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LidarDetectionData_reflection_ = NULL;
const ::google::protobuf::Descriptor* LidarDetection_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LidarDetection_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DetectionClassification_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_osi_5ffeaturedata_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_osi_5ffeaturedata_2eproto() {
  protobuf_AddDesc_osi_5ffeaturedata_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "osi_featuredata.proto");
  GOOGLE_CHECK(file != NULL);
  FeatureData_descriptor_ = file->message_type(0);
  static const int FeatureData_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureData, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureData, radar_sensor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureData, lidar_sensor_),
  };
  FeatureData_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      FeatureData_descriptor_,
      FeatureData::default_instance_,
      FeatureData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureData, _has_bits_[0]),
      -1,
      -1,
      sizeof(FeatureData),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FeatureData, _internal_metadata_),
      -1);
  SensorDetectionHeader_descriptor_ = file->message_type(1);
  static const int SensorDetectionHeader_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDetectionHeader, measurement_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDetectionHeader, cycle_counter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDetectionHeader, mounting_position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDetectionHeader, mounting_position_rmse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDetectionHeader, data_qualifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDetectionHeader, number_of_valid_detections_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDetectionHeader, sensor_id_),
  };
  SensorDetectionHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SensorDetectionHeader_descriptor_,
      SensorDetectionHeader::default_instance_,
      SensorDetectionHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDetectionHeader, _has_bits_[0]),
      -1,
      -1,
      sizeof(SensorDetectionHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SensorDetectionHeader, _internal_metadata_),
      -1);
  SensorDetectionHeader_DataQualifier_descriptor_ = SensorDetectionHeader_descriptor_->enum_type(0);
  RadarDetectionData_descriptor_ = file->message_type(2);
  static const int RadarDetectionData_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetectionData, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetectionData, detection_),
  };
  RadarDetectionData_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RadarDetectionData_descriptor_,
      RadarDetectionData::default_instance_,
      RadarDetectionData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetectionData, _has_bits_[0]),
      -1,
      -1,
      sizeof(RadarDetectionData),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetectionData, _internal_metadata_),
      -1);
  RadarDetection_descriptor_ = file->message_type(3);
  static const int RadarDetection_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, existence_probability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, object_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, position_rmse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, radial_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, radial_velocity_rmse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, rcs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, snr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, point_target_probability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, ambiguity_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, classification_),
  };
  RadarDetection_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RadarDetection_descriptor_,
      RadarDetection::default_instance_,
      RadarDetection_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, _has_bits_[0]),
      -1,
      -1,
      sizeof(RadarDetection),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RadarDetection, _internal_metadata_),
      -1);
  LidarDetectionData_descriptor_ = file->message_type(4);
  static const int LidarDetectionData_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetectionData, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetectionData, detection_),
  };
  LidarDetectionData_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LidarDetectionData_descriptor_,
      LidarDetectionData::default_instance_,
      LidarDetectionData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetectionData, _has_bits_[0]),
      -1,
      -1,
      sizeof(LidarDetectionData),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetectionData, _internal_metadata_),
      -1);
  LidarDetection_descriptor_ = file->message_type(5);
  static const int LidarDetection_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetection, existence_probability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetection, object_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetection, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetection, position_rmse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetection, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetection, height_rmse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetection, intensity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetection, free_space_probability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetection, classification_),
  };
  LidarDetection_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LidarDetection_descriptor_,
      LidarDetection::default_instance_,
      LidarDetection_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetection, _has_bits_[0]),
      -1,
      -1,
      sizeof(LidarDetection),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LidarDetection, _internal_metadata_),
      -1);
  DetectionClassification_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_osi_5ffeaturedata_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      FeatureData_descriptor_, &FeatureData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SensorDetectionHeader_descriptor_, &SensorDetectionHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RadarDetectionData_descriptor_, &RadarDetectionData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RadarDetection_descriptor_, &RadarDetection::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LidarDetectionData_descriptor_, &LidarDetectionData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LidarDetection_descriptor_, &LidarDetection::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_osi_5ffeaturedata_2eproto() {
  delete FeatureData::default_instance_;
  delete FeatureData_reflection_;
  delete SensorDetectionHeader::default_instance_;
  delete SensorDetectionHeader_reflection_;
  delete RadarDetectionData::default_instance_;
  delete RadarDetectionData_reflection_;
  delete RadarDetection::default_instance_;
  delete RadarDetection_reflection_;
  delete LidarDetectionData::default_instance_;
  delete LidarDetectionData_reflection_;
  delete LidarDetection::default_instance_;
  delete LidarDetection_reflection_;
}

void protobuf_AddDesc_osi_5ffeaturedata_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_osi_5ffeaturedata_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::osi3::protobuf_AddDesc_osi_5fversion_2eproto();
  ::osi3::protobuf_AddDesc_osi_5fcommon_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\025osi_featuredata.proto\022\004osi3\032\021osi_versi"
    "on.proto\032\020osi_common.proto\"\226\001\n\013FeatureDa"
    "ta\022\'\n\007version\030\001 \001(\0132\026.osi3.InterfaceVers"
    "ion\022.\n\014radar_sensor\030\002 \003(\0132\030.osi3.RadarDe"
    "tectionData\022.\n\014lidar_sensor\030\003 \003(\0132\030.osi3"
    ".LidarDetectionData\"\304\004\n\025SensorDetectionH"
    "eader\022)\n\020measurement_time\030\001 \001(\0132\017.osi3.T"
    "imestamp\022\025\n\rcycle_counter\030\002 \001(\004\0221\n\021mount"
    "ing_position\030\003 \001(\0132\026.osi3.MountingPositi"
    "on\0226\n\026mounting_position_rmse\030\004 \001(\0132\026.osi"
    "3.MountingPosition\022A\n\016data_qualifier\030\005 \001"
    "(\0162).osi3.SensorDetectionHeader.DataQual"
    "ifier\022\"\n\032number_of_valid_detections\030\006 \001("
    "\r\022#\n\tsensor_id\030\007 \001(\0132\020.osi3.Identifier\"\361"
    "\001\n\rDataQualifier\022\032\n\026DATA_QUALIFIER_UNKNO"
    "WN\020\000\022\030\n\024DATA_QUALIFIER_OTHER\020\001\022\034\n\030DATA_Q"
    "UALIFIER_AVAILABLE\020\002\022$\n DATA_QUALIFIER_A"
    "VAILABLE_REDUCED\020\003\022 \n\034DATA_QUALIFIER_NOT"
    "_AVAILABLE\020\004\022\034\n\030DATA_QUALIFIER_BLINDNESS"
    "\020\005\022&\n\"DATA_QUALIFIER_TEMPORARY_AVAILABLE"
    "\020\006\"j\n\022RadarDetectionData\022+\n\006header\030\001 \001(\013"
    "2\033.osi3.SensorDetectionHeader\022\'\n\tdetecti"
    "on\030\002 \003(\0132\024.osi3.RadarDetection\"\365\002\n\016Radar"
    "Detection\022\035\n\025existence_probability\030\001 \001(\001"
    "\022#\n\tobject_id\030\002 \001(\0132\020.osi3.Identifier\022#\n"
    "\010position\030\003 \001(\0132\021.osi3.Spherical3d\022(\n\rpo"
    "sition_rmse\030\004 \001(\0132\021.osi3.Spherical3d\022\027\n\017"
    "radial_velocity\030\005 \001(\001\022\034\n\024radial_velocity"
    "_rmse\030\006 \001(\001\022\013\n\003rcs\030\007 \001(\001\022\013\n\003snr\030\010 \001(\001\022 \n"
    "\030point_target_probability\030\t \001(\001\022&\n\014ambig"
    "uity_id\030\n \001(\0132\020.osi3.Identifier\0225\n\016class"
    "ification\030\013 \001(\0162\035.osi3.DetectionClassifi"
    "cation\"j\n\022LidarDetectionData\022+\n\006header\030\001"
    " \001(\0132\033.osi3.SensorDetectionHeader\022\'\n\tdet"
    "ection\030\002 \003(\0132\024.osi3.LidarDetection\"\262\002\n\016L"
    "idarDetection\022\035\n\025existence_probability\030\001"
    " \001(\001\022#\n\tobject_id\030\002 \001(\0132\020.osi3.Identifie"
    "r\022#\n\010position\030\003 \001(\0132\021.osi3.Spherical3d\022("
    "\n\rposition_rmse\030\004 \001(\0132\021.osi3.Spherical3d"
    "\022\016\n\006height\030\005 \001(\001\022\023\n\013height_rmse\030\006 \001(\001\022\021\n"
    "\tintensity\030\007 \001(\001\022\036\n\026free_space_probabili"
    "ty\030\010 \001(\001\0225\n\016classification\030\t \001(\0162\035.osi3."
    "DetectionClassification*\206\002\n\027DetectionCla"
    "ssification\022$\n DETECTION_CLASSIFICATION_"
    "UNKNOWN\020\000\022\"\n\036DETECTION_CLASSIFICATION_OT"
    "HER\020\001\022$\n DETECTION_CLASSIFICATION_INVALI"
    "D\020\002\022$\n DETECTION_CLASSIFICATION_CLUTTER\020"
    "\003\022)\n%DETECTION_CLASSIFICATION_OVERDRIVAB"
    "LE\020\004\022*\n&DETECTION_CLASSIFICATION_UNDERDR"
    "IVABLE\020\005B\002H\001", 1972);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "osi_featuredata.proto", &protobuf_RegisterTypes);
  FeatureData::default_instance_ = new FeatureData();
  SensorDetectionHeader::default_instance_ = new SensorDetectionHeader();
  RadarDetectionData::default_instance_ = new RadarDetectionData();
  RadarDetection::default_instance_ = new RadarDetection();
  LidarDetectionData::default_instance_ = new LidarDetectionData();
  LidarDetection::default_instance_ = new LidarDetection();
  FeatureData::default_instance_->InitAsDefaultInstance();
  SensorDetectionHeader::default_instance_->InitAsDefaultInstance();
  RadarDetectionData::default_instance_->InitAsDefaultInstance();
  RadarDetection::default_instance_->InitAsDefaultInstance();
  LidarDetectionData::default_instance_->InitAsDefaultInstance();
  LidarDetection::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_osi_5ffeaturedata_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_osi_5ffeaturedata_2eproto {
  StaticDescriptorInitializer_osi_5ffeaturedata_2eproto() {
    protobuf_AddDesc_osi_5ffeaturedata_2eproto();
  }
} static_descriptor_initializer_osi_5ffeaturedata_2eproto_;
const ::google::protobuf::EnumDescriptor* DetectionClassification_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DetectionClassification_descriptor_;
}
bool DetectionClassification_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FeatureData::kVersionFieldNumber;
const int FeatureData::kRadarSensorFieldNumber;
const int FeatureData::kLidarSensorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FeatureData::FeatureData()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.FeatureData)
}

void FeatureData::InitAsDefaultInstance() {
  version_ = const_cast< ::osi3::InterfaceVersion*>(&::osi3::InterfaceVersion::default_instance());
}

FeatureData::FeatureData(const FeatureData& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.FeatureData)
}

void FeatureData::SharedCtor() {
  _cached_size_ = 0;
  version_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FeatureData::~FeatureData() {
  // @@protoc_insertion_point(destructor:osi3.FeatureData)
  SharedDtor();
}

void FeatureData::SharedDtor() {
  if (this != default_instance_) {
    delete version_;
  }
}

void FeatureData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FeatureData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FeatureData_descriptor_;
}

const FeatureData& FeatureData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5ffeaturedata_2eproto();
  return *default_instance_;
}

FeatureData* FeatureData::default_instance_ = NULL;

FeatureData* FeatureData::New(::google::protobuf::Arena* arena) const {
  FeatureData* n = new FeatureData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FeatureData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.FeatureData)
  if (has_version()) {
    if (version_ != NULL) version_->::osi3::InterfaceVersion::Clear();
  }
  radar_sensor_.Clear();
  lidar_sensor_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool FeatureData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.FeatureData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.InterfaceVersion version = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_radar_sensor;
        break;
      }

      // repeated .osi3.RadarDetectionData radar_sensor = 2;
      case 2: {
        if (tag == 18) {
         parse_radar_sensor:
          DO_(input->IncrementRecursionDepth());
         parse_loop_radar_sensor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_radar_sensor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_radar_sensor;
        if (input->ExpectTag(26)) goto parse_loop_lidar_sensor;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .osi3.LidarDetectionData lidar_sensor = 3;
      case 3: {
        if (tag == 26) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_lidar_sensor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_lidar_sensor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_lidar_sensor;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.FeatureData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.FeatureData)
  return false;
#undef DO_
}

void FeatureData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.FeatureData)
  // optional .osi3.InterfaceVersion version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->version_, output);
  }

  // repeated .osi3.RadarDetectionData radar_sensor = 2;
  for (unsigned int i = 0, n = this->radar_sensor_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->radar_sensor(i), output);
  }

  // repeated .osi3.LidarDetectionData lidar_sensor = 3;
  for (unsigned int i = 0, n = this->lidar_sensor_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->lidar_sensor(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.FeatureData)
}

::google::protobuf::uint8* FeatureData::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.FeatureData)
  // optional .osi3.InterfaceVersion version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->version_, false, target);
  }

  // repeated .osi3.RadarDetectionData radar_sensor = 2;
  for (unsigned int i = 0, n = this->radar_sensor_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->radar_sensor(i), false, target);
  }

  // repeated .osi3.LidarDetectionData lidar_sensor = 3;
  for (unsigned int i = 0, n = this->lidar_sensor_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->lidar_sensor(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.FeatureData)
  return target;
}

int FeatureData::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.FeatureData)
  int total_size = 0;

  // optional .osi3.InterfaceVersion version = 1;
  if (has_version()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->version_);
  }

  // repeated .osi3.RadarDetectionData radar_sensor = 2;
  total_size += 1 * this->radar_sensor_size();
  for (int i = 0; i < this->radar_sensor_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->radar_sensor(i));
  }

  // repeated .osi3.LidarDetectionData lidar_sensor = 3;
  total_size += 1 * this->lidar_sensor_size();
  for (int i = 0; i < this->lidar_sensor_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lidar_sensor(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FeatureData::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.FeatureData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const FeatureData* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const FeatureData>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.FeatureData)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.FeatureData)
    MergeFrom(*source);
  }
}

void FeatureData::MergeFrom(const FeatureData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.FeatureData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  radar_sensor_.MergeFrom(from.radar_sensor_);
  lidar_sensor_.MergeFrom(from.lidar_sensor_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      mutable_version()->::osi3::InterfaceVersion::MergeFrom(from.version());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void FeatureData::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.FeatureData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FeatureData::CopyFrom(const FeatureData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.FeatureData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeatureData::IsInitialized() const {

  return true;
}

void FeatureData::Swap(FeatureData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FeatureData::InternalSwap(FeatureData* other) {
  std::swap(version_, other->version_);
  radar_sensor_.UnsafeArenaSwap(&other->radar_sensor_);
  lidar_sensor_.UnsafeArenaSwap(&other->lidar_sensor_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FeatureData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FeatureData_descriptor_;
  metadata.reflection = FeatureData_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FeatureData

// optional .osi3.InterfaceVersion version = 1;
bool FeatureData::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FeatureData::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
void FeatureData::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void FeatureData::clear_version() {
  if (version_ != NULL) version_->::osi3::InterfaceVersion::Clear();
  clear_has_version();
}
const ::osi3::InterfaceVersion& FeatureData::version() const {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.version)
  return version_ != NULL ? *version_ : *default_instance_->version_;
}
::osi3::InterfaceVersion* FeatureData::mutable_version() {
  set_has_version();
  if (version_ == NULL) {
    version_ = new ::osi3::InterfaceVersion;
  }
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.version)
  return version_;
}
::osi3::InterfaceVersion* FeatureData::release_version() {
  // @@protoc_insertion_point(field_release:osi3.FeatureData.version)
  clear_has_version();
  ::osi3::InterfaceVersion* temp = version_;
  version_ = NULL;
  return temp;
}
void FeatureData::set_allocated_version(::osi3::InterfaceVersion* version) {
  delete version_;
  version_ = version;
  if (version) {
    set_has_version();
  } else {
    clear_has_version();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.FeatureData.version)
}

// repeated .osi3.RadarDetectionData radar_sensor = 2;
int FeatureData::radar_sensor_size() const {
  return radar_sensor_.size();
}
void FeatureData::clear_radar_sensor() {
  radar_sensor_.Clear();
}
const ::osi3::RadarDetectionData& FeatureData::radar_sensor(int index) const {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.radar_sensor)
  return radar_sensor_.Get(index);
}
::osi3::RadarDetectionData* FeatureData::mutable_radar_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.radar_sensor)
  return radar_sensor_.Mutable(index);
}
::osi3::RadarDetectionData* FeatureData::add_radar_sensor() {
  // @@protoc_insertion_point(field_add:osi3.FeatureData.radar_sensor)
  return radar_sensor_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::RadarDetectionData >*
FeatureData::mutable_radar_sensor() {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.radar_sensor)
  return &radar_sensor_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetectionData >&
FeatureData::radar_sensor() const {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.radar_sensor)
  return radar_sensor_;
}

// repeated .osi3.LidarDetectionData lidar_sensor = 3;
int FeatureData::lidar_sensor_size() const {
  return lidar_sensor_.size();
}
void FeatureData::clear_lidar_sensor() {
  lidar_sensor_.Clear();
}
const ::osi3::LidarDetectionData& FeatureData::lidar_sensor(int index) const {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.lidar_sensor)
  return lidar_sensor_.Get(index);
}
::osi3::LidarDetectionData* FeatureData::mutable_lidar_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.lidar_sensor)
  return lidar_sensor_.Mutable(index);
}
::osi3::LidarDetectionData* FeatureData::add_lidar_sensor() {
  // @@protoc_insertion_point(field_add:osi3.FeatureData.lidar_sensor)
  return lidar_sensor_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::LidarDetectionData >*
FeatureData::mutable_lidar_sensor() {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.lidar_sensor)
  return &lidar_sensor_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetectionData >&
FeatureData::lidar_sensor() const {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.lidar_sensor)
  return lidar_sensor_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* SensorDetectionHeader_DataQualifier_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SensorDetectionHeader_DataQualifier_descriptor_;
}
bool SensorDetectionHeader_DataQualifier_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_UNKNOWN;
const SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_OTHER;
const SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_AVAILABLE;
const SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_AVAILABLE_REDUCED;
const SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_NOT_AVAILABLE;
const SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_BLINDNESS;
const SensorDetectionHeader_DataQualifier SensorDetectionHeader::DATA_QUALIFIER_TEMPORARY_AVAILABLE;
const SensorDetectionHeader_DataQualifier SensorDetectionHeader::DataQualifier_MIN;
const SensorDetectionHeader_DataQualifier SensorDetectionHeader::DataQualifier_MAX;
const int SensorDetectionHeader::DataQualifier_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SensorDetectionHeader::kMeasurementTimeFieldNumber;
const int SensorDetectionHeader::kCycleCounterFieldNumber;
const int SensorDetectionHeader::kMountingPositionFieldNumber;
const int SensorDetectionHeader::kMountingPositionRmseFieldNumber;
const int SensorDetectionHeader::kDataQualifierFieldNumber;
const int SensorDetectionHeader::kNumberOfValidDetectionsFieldNumber;
const int SensorDetectionHeader::kSensorIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SensorDetectionHeader::SensorDetectionHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.SensorDetectionHeader)
}

void SensorDetectionHeader::InitAsDefaultInstance() {
  measurement_time_ = const_cast< ::osi3::Timestamp*>(&::osi3::Timestamp::default_instance());
  mounting_position_ = const_cast< ::osi3::MountingPosition*>(&::osi3::MountingPosition::default_instance());
  mounting_position_rmse_ = const_cast< ::osi3::MountingPosition*>(&::osi3::MountingPosition::default_instance());
  sensor_id_ = const_cast< ::osi3::Identifier*>(&::osi3::Identifier::default_instance());
}

SensorDetectionHeader::SensorDetectionHeader(const SensorDetectionHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.SensorDetectionHeader)
}

void SensorDetectionHeader::SharedCtor() {
  _cached_size_ = 0;
  measurement_time_ = NULL;
  cycle_counter_ = GOOGLE_ULONGLONG(0);
  mounting_position_ = NULL;
  mounting_position_rmse_ = NULL;
  data_qualifier_ = 0;
  number_of_valid_detections_ = 0u;
  sensor_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SensorDetectionHeader::~SensorDetectionHeader() {
  // @@protoc_insertion_point(destructor:osi3.SensorDetectionHeader)
  SharedDtor();
}

void SensorDetectionHeader::SharedDtor() {
  if (this != default_instance_) {
    delete measurement_time_;
    delete mounting_position_;
    delete mounting_position_rmse_;
    delete sensor_id_;
  }
}

void SensorDetectionHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SensorDetectionHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SensorDetectionHeader_descriptor_;
}

const SensorDetectionHeader& SensorDetectionHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5ffeaturedata_2eproto();
  return *default_instance_;
}

SensorDetectionHeader* SensorDetectionHeader::default_instance_ = NULL;

SensorDetectionHeader* SensorDetectionHeader::New(::google::protobuf::Arena* arena) const {
  SensorDetectionHeader* n = new SensorDetectionHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SensorDetectionHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.SensorDetectionHeader)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(SensorDetectionHeader, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SensorDetectionHeader*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 127u) {
    ZR_(data_qualifier_, number_of_valid_detections_);
    if (has_measurement_time()) {
      if (measurement_time_ != NULL) measurement_time_->::osi3::Timestamp::Clear();
    }
    cycle_counter_ = GOOGLE_ULONGLONG(0);
    if (has_mounting_position()) {
      if (mounting_position_ != NULL) mounting_position_->::osi3::MountingPosition::Clear();
    }
    if (has_mounting_position_rmse()) {
      if (mounting_position_rmse_ != NULL) mounting_position_rmse_->::osi3::MountingPosition::Clear();
    }
    if (has_sensor_id()) {
      if (sensor_id_ != NULL) sensor_id_->::osi3::Identifier::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SensorDetectionHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.SensorDetectionHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.Timestamp measurement_time = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_measurement_time()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_cycle_counter;
        break;
      }

      // optional uint64 cycle_counter = 2;
      case 2: {
        if (tag == 16) {
         parse_cycle_counter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cycle_counter_)));
          set_has_cycle_counter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_mounting_position;
        break;
      }

      // optional .osi3.MountingPosition mounting_position = 3;
      case 3: {
        if (tag == 26) {
         parse_mounting_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mounting_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_mounting_position_rmse;
        break;
      }

      // optional .osi3.MountingPosition mounting_position_rmse = 4;
      case 4: {
        if (tag == 34) {
         parse_mounting_position_rmse:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mounting_position_rmse()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_data_qualifier;
        break;
      }

      // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
      case 5: {
        if (tag == 40) {
         parse_data_qualifier:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::osi3::SensorDetectionHeader_DataQualifier_IsValid(value)) {
            set_data_qualifier(static_cast< ::osi3::SensorDetectionHeader_DataQualifier >(value));
          } else {
            mutable_unknown_fields()->AddVarint(5, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_number_of_valid_detections;
        break;
      }

      // optional uint32 number_of_valid_detections = 6;
      case 6: {
        if (tag == 48) {
         parse_number_of_valid_detections:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &number_of_valid_detections_)));
          set_has_number_of_valid_detections();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_sensor_id;
        break;
      }

      // optional .osi3.Identifier sensor_id = 7;
      case 7: {
        if (tag == 58) {
         parse_sensor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sensor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.SensorDetectionHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.SensorDetectionHeader)
  return false;
#undef DO_
}

void SensorDetectionHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.SensorDetectionHeader)
  // optional .osi3.Timestamp measurement_time = 1;
  if (has_measurement_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->measurement_time_, output);
  }

  // optional uint64 cycle_counter = 2;
  if (has_cycle_counter()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->cycle_counter(), output);
  }

  // optional .osi3.MountingPosition mounting_position = 3;
  if (has_mounting_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->mounting_position_, output);
  }

  // optional .osi3.MountingPosition mounting_position_rmse = 4;
  if (has_mounting_position_rmse()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->mounting_position_rmse_, output);
  }

  // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
  if (has_data_qualifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->data_qualifier(), output);
  }

  // optional uint32 number_of_valid_detections = 6;
  if (has_number_of_valid_detections()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->number_of_valid_detections(), output);
  }

  // optional .osi3.Identifier sensor_id = 7;
  if (has_sensor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->sensor_id_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.SensorDetectionHeader)
}

::google::protobuf::uint8* SensorDetectionHeader::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.SensorDetectionHeader)
  // optional .osi3.Timestamp measurement_time = 1;
  if (has_measurement_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->measurement_time_, false, target);
  }

  // optional uint64 cycle_counter = 2;
  if (has_cycle_counter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->cycle_counter(), target);
  }

  // optional .osi3.MountingPosition mounting_position = 3;
  if (has_mounting_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->mounting_position_, false, target);
  }

  // optional .osi3.MountingPosition mounting_position_rmse = 4;
  if (has_mounting_position_rmse()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->mounting_position_rmse_, false, target);
  }

  // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
  if (has_data_qualifier()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      5, this->data_qualifier(), target);
  }

  // optional uint32 number_of_valid_detections = 6;
  if (has_number_of_valid_detections()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->number_of_valid_detections(), target);
  }

  // optional .osi3.Identifier sensor_id = 7;
  if (has_sensor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->sensor_id_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.SensorDetectionHeader)
  return target;
}

int SensorDetectionHeader::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.SensorDetectionHeader)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 127u) {
    // optional .osi3.Timestamp measurement_time = 1;
    if (has_measurement_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->measurement_time_);
    }

    // optional uint64 cycle_counter = 2;
    if (has_cycle_counter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cycle_counter());
    }

    // optional .osi3.MountingPosition mounting_position = 3;
    if (has_mounting_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->mounting_position_);
    }

    // optional .osi3.MountingPosition mounting_position_rmse = 4;
    if (has_mounting_position_rmse()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->mounting_position_rmse_);
    }

    // optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
    if (has_data_qualifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->data_qualifier());
    }

    // optional uint32 number_of_valid_detections = 6;
    if (has_number_of_valid_detections()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->number_of_valid_detections());
    }

    // optional .osi3.Identifier sensor_id = 7;
    if (has_sensor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->sensor_id_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SensorDetectionHeader::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.SensorDetectionHeader)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SensorDetectionHeader* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SensorDetectionHeader>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.SensorDetectionHeader)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.SensorDetectionHeader)
    MergeFrom(*source);
  }
}

void SensorDetectionHeader::MergeFrom(const SensorDetectionHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.SensorDetectionHeader)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_measurement_time()) {
      mutable_measurement_time()->::osi3::Timestamp::MergeFrom(from.measurement_time());
    }
    if (from.has_cycle_counter()) {
      set_cycle_counter(from.cycle_counter());
    }
    if (from.has_mounting_position()) {
      mutable_mounting_position()->::osi3::MountingPosition::MergeFrom(from.mounting_position());
    }
    if (from.has_mounting_position_rmse()) {
      mutable_mounting_position_rmse()->::osi3::MountingPosition::MergeFrom(from.mounting_position_rmse());
    }
    if (from.has_data_qualifier()) {
      set_data_qualifier(from.data_qualifier());
    }
    if (from.has_number_of_valid_detections()) {
      set_number_of_valid_detections(from.number_of_valid_detections());
    }
    if (from.has_sensor_id()) {
      mutable_sensor_id()->::osi3::Identifier::MergeFrom(from.sensor_id());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SensorDetectionHeader::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.SensorDetectionHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SensorDetectionHeader::CopyFrom(const SensorDetectionHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.SensorDetectionHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SensorDetectionHeader::IsInitialized() const {

  return true;
}

void SensorDetectionHeader::Swap(SensorDetectionHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SensorDetectionHeader::InternalSwap(SensorDetectionHeader* other) {
  std::swap(measurement_time_, other->measurement_time_);
  std::swap(cycle_counter_, other->cycle_counter_);
  std::swap(mounting_position_, other->mounting_position_);
  std::swap(mounting_position_rmse_, other->mounting_position_rmse_);
  std::swap(data_qualifier_, other->data_qualifier_);
  std::swap(number_of_valid_detections_, other->number_of_valid_detections_);
  std::swap(sensor_id_, other->sensor_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SensorDetectionHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SensorDetectionHeader_descriptor_;
  metadata.reflection = SensorDetectionHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SensorDetectionHeader

// optional .osi3.Timestamp measurement_time = 1;
bool SensorDetectionHeader::has_measurement_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SensorDetectionHeader::set_has_measurement_time() {
  _has_bits_[0] |= 0x00000001u;
}
void SensorDetectionHeader::clear_has_measurement_time() {
  _has_bits_[0] &= ~0x00000001u;
}
void SensorDetectionHeader::clear_measurement_time() {
  if (measurement_time_ != NULL) measurement_time_->::osi3::Timestamp::Clear();
  clear_has_measurement_time();
}
const ::osi3::Timestamp& SensorDetectionHeader::measurement_time() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.measurement_time)
  return measurement_time_ != NULL ? *measurement_time_ : *default_instance_->measurement_time_;
}
::osi3::Timestamp* SensorDetectionHeader::mutable_measurement_time() {
  set_has_measurement_time();
  if (measurement_time_ == NULL) {
    measurement_time_ = new ::osi3::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.measurement_time)
  return measurement_time_;
}
::osi3::Timestamp* SensorDetectionHeader::release_measurement_time() {
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.measurement_time)
  clear_has_measurement_time();
  ::osi3::Timestamp* temp = measurement_time_;
  measurement_time_ = NULL;
  return temp;
}
void SensorDetectionHeader::set_allocated_measurement_time(::osi3::Timestamp* measurement_time) {
  delete measurement_time_;
  measurement_time_ = measurement_time;
  if (measurement_time) {
    set_has_measurement_time();
  } else {
    clear_has_measurement_time();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.measurement_time)
}

// optional uint64 cycle_counter = 2;
bool SensorDetectionHeader::has_cycle_counter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SensorDetectionHeader::set_has_cycle_counter() {
  _has_bits_[0] |= 0x00000002u;
}
void SensorDetectionHeader::clear_has_cycle_counter() {
  _has_bits_[0] &= ~0x00000002u;
}
void SensorDetectionHeader::clear_cycle_counter() {
  cycle_counter_ = GOOGLE_ULONGLONG(0);
  clear_has_cycle_counter();
}
 ::google::protobuf::uint64 SensorDetectionHeader::cycle_counter() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.cycle_counter)
  return cycle_counter_;
}
 void SensorDetectionHeader::set_cycle_counter(::google::protobuf::uint64 value) {
  set_has_cycle_counter();
  cycle_counter_ = value;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.cycle_counter)
}

// optional .osi3.MountingPosition mounting_position = 3;
bool SensorDetectionHeader::has_mounting_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SensorDetectionHeader::set_has_mounting_position() {
  _has_bits_[0] |= 0x00000004u;
}
void SensorDetectionHeader::clear_has_mounting_position() {
  _has_bits_[0] &= ~0x00000004u;
}
void SensorDetectionHeader::clear_mounting_position() {
  if (mounting_position_ != NULL) mounting_position_->::osi3::MountingPosition::Clear();
  clear_has_mounting_position();
}
const ::osi3::MountingPosition& SensorDetectionHeader::mounting_position() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.mounting_position)
  return mounting_position_ != NULL ? *mounting_position_ : *default_instance_->mounting_position_;
}
::osi3::MountingPosition* SensorDetectionHeader::mutable_mounting_position() {
  set_has_mounting_position();
  if (mounting_position_ == NULL) {
    mounting_position_ = new ::osi3::MountingPosition;
  }
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.mounting_position)
  return mounting_position_;
}
::osi3::MountingPosition* SensorDetectionHeader::release_mounting_position() {
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.mounting_position)
  clear_has_mounting_position();
  ::osi3::MountingPosition* temp = mounting_position_;
  mounting_position_ = NULL;
  return temp;
}
void SensorDetectionHeader::set_allocated_mounting_position(::osi3::MountingPosition* mounting_position) {
  delete mounting_position_;
  mounting_position_ = mounting_position;
  if (mounting_position) {
    set_has_mounting_position();
  } else {
    clear_has_mounting_position();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.mounting_position)
}

// optional .osi3.MountingPosition mounting_position_rmse = 4;
bool SensorDetectionHeader::has_mounting_position_rmse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SensorDetectionHeader::set_has_mounting_position_rmse() {
  _has_bits_[0] |= 0x00000008u;
}
void SensorDetectionHeader::clear_has_mounting_position_rmse() {
  _has_bits_[0] &= ~0x00000008u;
}
void SensorDetectionHeader::clear_mounting_position_rmse() {
  if (mounting_position_rmse_ != NULL) mounting_position_rmse_->::osi3::MountingPosition::Clear();
  clear_has_mounting_position_rmse();
}
const ::osi3::MountingPosition& SensorDetectionHeader::mounting_position_rmse() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.mounting_position_rmse)
  return mounting_position_rmse_ != NULL ? *mounting_position_rmse_ : *default_instance_->mounting_position_rmse_;
}
::osi3::MountingPosition* SensorDetectionHeader::mutable_mounting_position_rmse() {
  set_has_mounting_position_rmse();
  if (mounting_position_rmse_ == NULL) {
    mounting_position_rmse_ = new ::osi3::MountingPosition;
  }
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.mounting_position_rmse)
  return mounting_position_rmse_;
}
::osi3::MountingPosition* SensorDetectionHeader::release_mounting_position_rmse() {
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.mounting_position_rmse)
  clear_has_mounting_position_rmse();
  ::osi3::MountingPosition* temp = mounting_position_rmse_;
  mounting_position_rmse_ = NULL;
  return temp;
}
void SensorDetectionHeader::set_allocated_mounting_position_rmse(::osi3::MountingPosition* mounting_position_rmse) {
  delete mounting_position_rmse_;
  mounting_position_rmse_ = mounting_position_rmse;
  if (mounting_position_rmse) {
    set_has_mounting_position_rmse();
  } else {
    clear_has_mounting_position_rmse();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.mounting_position_rmse)
}

// optional .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
bool SensorDetectionHeader::has_data_qualifier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void SensorDetectionHeader::set_has_data_qualifier() {
  _has_bits_[0] |= 0x00000010u;
}
void SensorDetectionHeader::clear_has_data_qualifier() {
  _has_bits_[0] &= ~0x00000010u;
}
void SensorDetectionHeader::clear_data_qualifier() {
  data_qualifier_ = 0;
  clear_has_data_qualifier();
}
 ::osi3::SensorDetectionHeader_DataQualifier SensorDetectionHeader::data_qualifier() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.data_qualifier)
  return static_cast< ::osi3::SensorDetectionHeader_DataQualifier >(data_qualifier_);
}
 void SensorDetectionHeader::set_data_qualifier(::osi3::SensorDetectionHeader_DataQualifier value) {
  assert(::osi3::SensorDetectionHeader_DataQualifier_IsValid(value));
  set_has_data_qualifier();
  data_qualifier_ = value;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.data_qualifier)
}

// optional uint32 number_of_valid_detections = 6;
bool SensorDetectionHeader::has_number_of_valid_detections() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void SensorDetectionHeader::set_has_number_of_valid_detections() {
  _has_bits_[0] |= 0x00000020u;
}
void SensorDetectionHeader::clear_has_number_of_valid_detections() {
  _has_bits_[0] &= ~0x00000020u;
}
void SensorDetectionHeader::clear_number_of_valid_detections() {
  number_of_valid_detections_ = 0u;
  clear_has_number_of_valid_detections();
}
 ::google::protobuf::uint32 SensorDetectionHeader::number_of_valid_detections() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.number_of_valid_detections)
  return number_of_valid_detections_;
}
 void SensorDetectionHeader::set_number_of_valid_detections(::google::protobuf::uint32 value) {
  set_has_number_of_valid_detections();
  number_of_valid_detections_ = value;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.number_of_valid_detections)
}

// optional .osi3.Identifier sensor_id = 7;
bool SensorDetectionHeader::has_sensor_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void SensorDetectionHeader::set_has_sensor_id() {
  _has_bits_[0] |= 0x00000040u;
}
void SensorDetectionHeader::clear_has_sensor_id() {
  _has_bits_[0] &= ~0x00000040u;
}
void SensorDetectionHeader::clear_sensor_id() {
  if (sensor_id_ != NULL) sensor_id_->::osi3::Identifier::Clear();
  clear_has_sensor_id();
}
const ::osi3::Identifier& SensorDetectionHeader::sensor_id() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.sensor_id)
  return sensor_id_ != NULL ? *sensor_id_ : *default_instance_->sensor_id_;
}
::osi3::Identifier* SensorDetectionHeader::mutable_sensor_id() {
  set_has_sensor_id();
  if (sensor_id_ == NULL) {
    sensor_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.sensor_id)
  return sensor_id_;
}
::osi3::Identifier* SensorDetectionHeader::release_sensor_id() {
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.sensor_id)
  clear_has_sensor_id();
  ::osi3::Identifier* temp = sensor_id_;
  sensor_id_ = NULL;
  return temp;
}
void SensorDetectionHeader::set_allocated_sensor_id(::osi3::Identifier* sensor_id) {
  delete sensor_id_;
  sensor_id_ = sensor_id;
  if (sensor_id) {
    set_has_sensor_id();
  } else {
    clear_has_sensor_id();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.sensor_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RadarDetectionData::kHeaderFieldNumber;
const int RadarDetectionData::kDetectionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RadarDetectionData::RadarDetectionData()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.RadarDetectionData)
}

void RadarDetectionData::InitAsDefaultInstance() {
  header_ = const_cast< ::osi3::SensorDetectionHeader*>(&::osi3::SensorDetectionHeader::default_instance());
}

RadarDetectionData::RadarDetectionData(const RadarDetectionData& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.RadarDetectionData)
}

void RadarDetectionData::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RadarDetectionData::~RadarDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.RadarDetectionData)
  SharedDtor();
}

void RadarDetectionData::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void RadarDetectionData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RadarDetectionData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RadarDetectionData_descriptor_;
}

const RadarDetectionData& RadarDetectionData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5ffeaturedata_2eproto();
  return *default_instance_;
}

RadarDetectionData* RadarDetectionData::default_instance_ = NULL;

RadarDetectionData* RadarDetectionData::New(::google::protobuf::Arena* arena) const {
  RadarDetectionData* n = new RadarDetectionData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RadarDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.RadarDetectionData)
  if (has_header()) {
    if (header_ != NULL) header_->::osi3::SensorDetectionHeader::Clear();
  }
  detection_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RadarDetectionData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.RadarDetectionData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.SensorDetectionHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_detection;
        break;
      }

      // repeated .osi3.RadarDetection detection = 2;
      case 2: {
        if (tag == 18) {
         parse_detection:
          DO_(input->IncrementRecursionDepth());
         parse_loop_detection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_detection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_detection;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.RadarDetectionData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.RadarDetectionData)
  return false;
#undef DO_
}

void RadarDetectionData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.RadarDetectionData)
  // optional .osi3.SensorDetectionHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .osi3.RadarDetection detection = 2;
  for (unsigned int i = 0, n = this->detection_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->detection(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.RadarDetectionData)
}

::google::protobuf::uint8* RadarDetectionData::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.RadarDetectionData)
  // optional .osi3.SensorDetectionHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, false, target);
  }

  // repeated .osi3.RadarDetection detection = 2;
  for (unsigned int i = 0, n = this->detection_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->detection(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.RadarDetectionData)
  return target;
}

int RadarDetectionData::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.RadarDetectionData)
  int total_size = 0;

  // optional .osi3.SensorDetectionHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .osi3.RadarDetection detection = 2;
  total_size += 1 * this->detection_size();
  for (int i = 0; i < this->detection_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->detection(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RadarDetectionData::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.RadarDetectionData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RadarDetectionData* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RadarDetectionData>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.RadarDetectionData)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.RadarDetectionData)
    MergeFrom(*source);
  }
}

void RadarDetectionData::MergeFrom(const RadarDetectionData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.RadarDetectionData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  detection_.MergeFrom(from.detection_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::osi3::SensorDetectionHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RadarDetectionData::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.RadarDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RadarDetectionData::CopyFrom(const RadarDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.RadarDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadarDetectionData::IsInitialized() const {

  return true;
}

void RadarDetectionData::Swap(RadarDetectionData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RadarDetectionData::InternalSwap(RadarDetectionData* other) {
  std::swap(header_, other->header_);
  detection_.UnsafeArenaSwap(&other->detection_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RadarDetectionData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RadarDetectionData_descriptor_;
  metadata.reflection = RadarDetectionData_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RadarDetectionData

// optional .osi3.SensorDetectionHeader header = 1;
bool RadarDetectionData::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RadarDetectionData::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void RadarDetectionData::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void RadarDetectionData::clear_header() {
  if (header_ != NULL) header_->::osi3::SensorDetectionHeader::Clear();
  clear_has_header();
}
const ::osi3::SensorDetectionHeader& RadarDetectionData::header() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetectionData.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::osi3::SensorDetectionHeader* RadarDetectionData::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::osi3::SensorDetectionHeader;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetectionData.header)
  return header_;
}
::osi3::SensorDetectionHeader* RadarDetectionData::release_header() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetectionData.header)
  clear_has_header();
  ::osi3::SensorDetectionHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void RadarDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetectionData.header)
}

// repeated .osi3.RadarDetection detection = 2;
int RadarDetectionData::detection_size() const {
  return detection_.size();
}
void RadarDetectionData::clear_detection() {
  detection_.Clear();
}
const ::osi3::RadarDetection& RadarDetectionData::detection(int index) const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetectionData.detection)
  return detection_.Get(index);
}
::osi3::RadarDetection* RadarDetectionData::mutable_detection(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetectionData.detection)
  return detection_.Mutable(index);
}
::osi3::RadarDetection* RadarDetectionData::add_detection() {
  // @@protoc_insertion_point(field_add:osi3.RadarDetectionData.detection)
  return detection_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::RadarDetection >*
RadarDetectionData::mutable_detection() {
  // @@protoc_insertion_point(field_mutable_list:osi3.RadarDetectionData.detection)
  return &detection_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::RadarDetection >&
RadarDetectionData::detection() const {
  // @@protoc_insertion_point(field_list:osi3.RadarDetectionData.detection)
  return detection_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RadarDetection::kExistenceProbabilityFieldNumber;
const int RadarDetection::kObjectIdFieldNumber;
const int RadarDetection::kPositionFieldNumber;
const int RadarDetection::kPositionRmseFieldNumber;
const int RadarDetection::kRadialVelocityFieldNumber;
const int RadarDetection::kRadialVelocityRmseFieldNumber;
const int RadarDetection::kRcsFieldNumber;
const int RadarDetection::kSnrFieldNumber;
const int RadarDetection::kPointTargetProbabilityFieldNumber;
const int RadarDetection::kAmbiguityIdFieldNumber;
const int RadarDetection::kClassificationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RadarDetection::RadarDetection()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.RadarDetection)
}

void RadarDetection::InitAsDefaultInstance() {
  object_id_ = const_cast< ::osi3::Identifier*>(&::osi3::Identifier::default_instance());
  position_ = const_cast< ::osi3::Spherical3d*>(&::osi3::Spherical3d::default_instance());
  position_rmse_ = const_cast< ::osi3::Spherical3d*>(&::osi3::Spherical3d::default_instance());
  ambiguity_id_ = const_cast< ::osi3::Identifier*>(&::osi3::Identifier::default_instance());
}

RadarDetection::RadarDetection(const RadarDetection& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.RadarDetection)
}

void RadarDetection::SharedCtor() {
  _cached_size_ = 0;
  existence_probability_ = 0;
  object_id_ = NULL;
  position_ = NULL;
  position_rmse_ = NULL;
  radial_velocity_ = 0;
  radial_velocity_rmse_ = 0;
  rcs_ = 0;
  snr_ = 0;
  point_target_probability_ = 0;
  ambiguity_id_ = NULL;
  classification_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RadarDetection::~RadarDetection() {
  // @@protoc_insertion_point(destructor:osi3.RadarDetection)
  SharedDtor();
}

void RadarDetection::SharedDtor() {
  if (this != default_instance_) {
    delete object_id_;
    delete position_;
    delete position_rmse_;
    delete ambiguity_id_;
  }
}

void RadarDetection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RadarDetection::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RadarDetection_descriptor_;
}

const RadarDetection& RadarDetection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5ffeaturedata_2eproto();
  return *default_instance_;
}

RadarDetection* RadarDetection::default_instance_ = NULL;

RadarDetection* RadarDetection::New(::google::protobuf::Arena* arena) const {
  RadarDetection* n = new RadarDetection;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RadarDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.RadarDetection)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RadarDetection, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RadarDetection*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(radial_velocity_, snr_);
    existence_probability_ = 0;
    if (has_object_id()) {
      if (object_id_ != NULL) object_id_->::osi3::Identifier::Clear();
    }
    if (has_position()) {
      if (position_ != NULL) position_->::osi3::Spherical3d::Clear();
    }
    if (has_position_rmse()) {
      if (position_rmse_ != NULL) position_rmse_->::osi3::Spherical3d::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 1792u) {
    point_target_probability_ = 0;
    if (has_ambiguity_id()) {
      if (ambiguity_id_ != NULL) ambiguity_id_->::osi3::Identifier::Clear();
    }
    classification_ = 0;
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RadarDetection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.RadarDetection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double existence_probability = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &existence_probability_)));
          set_has_existence_probability();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_object_id;
        break;
      }

      // optional .osi3.Identifier object_id = 2;
      case 2: {
        if (tag == 18) {
         parse_object_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_object_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_position;
        break;
      }

      // optional .osi3.Spherical3d position = 3;
      case 3: {
        if (tag == 26) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_position_rmse;
        break;
      }

      // optional .osi3.Spherical3d position_rmse = 4;
      case 4: {
        if (tag == 34) {
         parse_position_rmse:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position_rmse()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_radial_velocity;
        break;
      }

      // optional double radial_velocity = 5;
      case 5: {
        if (tag == 41) {
         parse_radial_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &radial_velocity_)));
          set_has_radial_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_radial_velocity_rmse;
        break;
      }

      // optional double radial_velocity_rmse = 6;
      case 6: {
        if (tag == 49) {
         parse_radial_velocity_rmse:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &radial_velocity_rmse_)));
          set_has_radial_velocity_rmse();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_rcs;
        break;
      }

      // optional double rcs = 7;
      case 7: {
        if (tag == 57) {
         parse_rcs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &rcs_)));
          set_has_rcs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(65)) goto parse_snr;
        break;
      }

      // optional double snr = 8;
      case 8: {
        if (tag == 65) {
         parse_snr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &snr_)));
          set_has_snr();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_point_target_probability;
        break;
      }

      // optional double point_target_probability = 9;
      case 9: {
        if (tag == 73) {
         parse_point_target_probability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &point_target_probability_)));
          set_has_point_target_probability();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_ambiguity_id;
        break;
      }

      // optional .osi3.Identifier ambiguity_id = 10;
      case 10: {
        if (tag == 82) {
         parse_ambiguity_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ambiguity_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_classification;
        break;
      }

      // optional .osi3.DetectionClassification classification = 11;
      case 11: {
        if (tag == 88) {
         parse_classification:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::osi3::DetectionClassification_IsValid(value)) {
            set_classification(static_cast< ::osi3::DetectionClassification >(value));
          } else {
            mutable_unknown_fields()->AddVarint(11, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.RadarDetection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.RadarDetection)
  return false;
#undef DO_
}

void RadarDetection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.RadarDetection)
  // optional double existence_probability = 1;
  if (has_existence_probability()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->existence_probability(), output);
  }

  // optional .osi3.Identifier object_id = 2;
  if (has_object_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->object_id_, output);
  }

  // optional .osi3.Spherical3d position = 3;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->position_, output);
  }

  // optional .osi3.Spherical3d position_rmse = 4;
  if (has_position_rmse()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->position_rmse_, output);
  }

  // optional double radial_velocity = 5;
  if (has_radial_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->radial_velocity(), output);
  }

  // optional double radial_velocity_rmse = 6;
  if (has_radial_velocity_rmse()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->radial_velocity_rmse(), output);
  }

  // optional double rcs = 7;
  if (has_rcs()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->rcs(), output);
  }

  // optional double snr = 8;
  if (has_snr()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->snr(), output);
  }

  // optional double point_target_probability = 9;
  if (has_point_target_probability()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->point_target_probability(), output);
  }

  // optional .osi3.Identifier ambiguity_id = 10;
  if (has_ambiguity_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->ambiguity_id_, output);
  }

  // optional .osi3.DetectionClassification classification = 11;
  if (has_classification()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      11, this->classification(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.RadarDetection)
}

::google::protobuf::uint8* RadarDetection::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.RadarDetection)
  // optional double existence_probability = 1;
  if (has_existence_probability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->existence_probability(), target);
  }

  // optional .osi3.Identifier object_id = 2;
  if (has_object_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->object_id_, false, target);
  }

  // optional .osi3.Spherical3d position = 3;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->position_, false, target);
  }

  // optional .osi3.Spherical3d position_rmse = 4;
  if (has_position_rmse()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->position_rmse_, false, target);
  }

  // optional double radial_velocity = 5;
  if (has_radial_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->radial_velocity(), target);
  }

  // optional double radial_velocity_rmse = 6;
  if (has_radial_velocity_rmse()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->radial_velocity_rmse(), target);
  }

  // optional double rcs = 7;
  if (has_rcs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->rcs(), target);
  }

  // optional double snr = 8;
  if (has_snr()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->snr(), target);
  }

  // optional double point_target_probability = 9;
  if (has_point_target_probability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->point_target_probability(), target);
  }

  // optional .osi3.Identifier ambiguity_id = 10;
  if (has_ambiguity_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, *this->ambiguity_id_, false, target);
  }

  // optional .osi3.DetectionClassification classification = 11;
  if (has_classification()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      11, this->classification(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.RadarDetection)
  return target;
}

int RadarDetection::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.RadarDetection)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional double existence_probability = 1;
    if (has_existence_probability()) {
      total_size += 1 + 8;
    }

    // optional .osi3.Identifier object_id = 2;
    if (has_object_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->object_id_);
    }

    // optional .osi3.Spherical3d position = 3;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->position_);
    }

    // optional .osi3.Spherical3d position_rmse = 4;
    if (has_position_rmse()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->position_rmse_);
    }

    // optional double radial_velocity = 5;
    if (has_radial_velocity()) {
      total_size += 1 + 8;
    }

    // optional double radial_velocity_rmse = 6;
    if (has_radial_velocity_rmse()) {
      total_size += 1 + 8;
    }

    // optional double rcs = 7;
    if (has_rcs()) {
      total_size += 1 + 8;
    }

    // optional double snr = 8;
    if (has_snr()) {
      total_size += 1 + 8;
    }

  }
  if (_has_bits_[8 / 32] & 1792u) {
    // optional double point_target_probability = 9;
    if (has_point_target_probability()) {
      total_size += 1 + 8;
    }

    // optional .osi3.Identifier ambiguity_id = 10;
    if (has_ambiguity_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->ambiguity_id_);
    }

    // optional .osi3.DetectionClassification classification = 11;
    if (has_classification()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->classification());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RadarDetection::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.RadarDetection)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RadarDetection* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RadarDetection>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.RadarDetection)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.RadarDetection)
    MergeFrom(*source);
  }
}

void RadarDetection::MergeFrom(const RadarDetection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.RadarDetection)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_existence_probability()) {
      set_existence_probability(from.existence_probability());
    }
    if (from.has_object_id()) {
      mutable_object_id()->::osi3::Identifier::MergeFrom(from.object_id());
    }
    if (from.has_position()) {
      mutable_position()->::osi3::Spherical3d::MergeFrom(from.position());
    }
    if (from.has_position_rmse()) {
      mutable_position_rmse()->::osi3::Spherical3d::MergeFrom(from.position_rmse());
    }
    if (from.has_radial_velocity()) {
      set_radial_velocity(from.radial_velocity());
    }
    if (from.has_radial_velocity_rmse()) {
      set_radial_velocity_rmse(from.radial_velocity_rmse());
    }
    if (from.has_rcs()) {
      set_rcs(from.rcs());
    }
    if (from.has_snr()) {
      set_snr(from.snr());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_point_target_probability()) {
      set_point_target_probability(from.point_target_probability());
    }
    if (from.has_ambiguity_id()) {
      mutable_ambiguity_id()->::osi3::Identifier::MergeFrom(from.ambiguity_id());
    }
    if (from.has_classification()) {
      set_classification(from.classification());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RadarDetection::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.RadarDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RadarDetection::CopyFrom(const RadarDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.RadarDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadarDetection::IsInitialized() const {

  return true;
}

void RadarDetection::Swap(RadarDetection* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RadarDetection::InternalSwap(RadarDetection* other) {
  std::swap(existence_probability_, other->existence_probability_);
  std::swap(object_id_, other->object_id_);
  std::swap(position_, other->position_);
  std::swap(position_rmse_, other->position_rmse_);
  std::swap(radial_velocity_, other->radial_velocity_);
  std::swap(radial_velocity_rmse_, other->radial_velocity_rmse_);
  std::swap(rcs_, other->rcs_);
  std::swap(snr_, other->snr_);
  std::swap(point_target_probability_, other->point_target_probability_);
  std::swap(ambiguity_id_, other->ambiguity_id_);
  std::swap(classification_, other->classification_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RadarDetection::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RadarDetection_descriptor_;
  metadata.reflection = RadarDetection_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RadarDetection

// optional double existence_probability = 1;
bool RadarDetection::has_existence_probability() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RadarDetection::set_has_existence_probability() {
  _has_bits_[0] |= 0x00000001u;
}
void RadarDetection::clear_has_existence_probability() {
  _has_bits_[0] &= ~0x00000001u;
}
void RadarDetection::clear_existence_probability() {
  existence_probability_ = 0;
  clear_has_existence_probability();
}
 double RadarDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.existence_probability)
  return existence_probability_;
}
 void RadarDetection::set_existence_probability(double value) {
  set_has_existence_probability();
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.existence_probability)
}

// optional .osi3.Identifier object_id = 2;
bool RadarDetection::has_object_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RadarDetection::set_has_object_id() {
  _has_bits_[0] |= 0x00000002u;
}
void RadarDetection::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void RadarDetection::clear_object_id() {
  if (object_id_ != NULL) object_id_->::osi3::Identifier::Clear();
  clear_has_object_id();
}
const ::osi3::Identifier& RadarDetection::object_id() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.object_id)
  return object_id_ != NULL ? *object_id_ : *default_instance_->object_id_;
}
::osi3::Identifier* RadarDetection::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == NULL) {
    object_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.object_id)
  return object_id_;
}
::osi3::Identifier* RadarDetection::release_object_id() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.object_id)
  clear_has_object_id();
  ::osi3::Identifier* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
void RadarDetection::set_allocated_object_id(::osi3::Identifier* object_id) {
  delete object_id_;
  object_id_ = object_id;
  if (object_id) {
    set_has_object_id();
  } else {
    clear_has_object_id();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.object_id)
}

// optional .osi3.Spherical3d position = 3;
bool RadarDetection::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RadarDetection::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
void RadarDetection::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
void RadarDetection::clear_position() {
  if (position_ != NULL) position_->::osi3::Spherical3d::Clear();
  clear_has_position();
}
const ::osi3::Spherical3d& RadarDetection::position() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
::osi3::Spherical3d* RadarDetection::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::osi3::Spherical3d;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.position)
  return position_;
}
::osi3::Spherical3d* RadarDetection::release_position() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.position)
  clear_has_position();
  ::osi3::Spherical3d* temp = position_;
  position_ = NULL;
  return temp;
}
void RadarDetection::set_allocated_position(::osi3::Spherical3d* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.position)
}

// optional .osi3.Spherical3d position_rmse = 4;
bool RadarDetection::has_position_rmse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RadarDetection::set_has_position_rmse() {
  _has_bits_[0] |= 0x00000008u;
}
void RadarDetection::clear_has_position_rmse() {
  _has_bits_[0] &= ~0x00000008u;
}
void RadarDetection::clear_position_rmse() {
  if (position_rmse_ != NULL) position_rmse_->::osi3::Spherical3d::Clear();
  clear_has_position_rmse();
}
const ::osi3::Spherical3d& RadarDetection::position_rmse() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.position_rmse)
  return position_rmse_ != NULL ? *position_rmse_ : *default_instance_->position_rmse_;
}
::osi3::Spherical3d* RadarDetection::mutable_position_rmse() {
  set_has_position_rmse();
  if (position_rmse_ == NULL) {
    position_rmse_ = new ::osi3::Spherical3d;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.position_rmse)
  return position_rmse_;
}
::osi3::Spherical3d* RadarDetection::release_position_rmse() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.position_rmse)
  clear_has_position_rmse();
  ::osi3::Spherical3d* temp = position_rmse_;
  position_rmse_ = NULL;
  return temp;
}
void RadarDetection::set_allocated_position_rmse(::osi3::Spherical3d* position_rmse) {
  delete position_rmse_;
  position_rmse_ = position_rmse;
  if (position_rmse) {
    set_has_position_rmse();
  } else {
    clear_has_position_rmse();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.position_rmse)
}

// optional double radial_velocity = 5;
bool RadarDetection::has_radial_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RadarDetection::set_has_radial_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
void RadarDetection::clear_has_radial_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
void RadarDetection::clear_radial_velocity() {
  radial_velocity_ = 0;
  clear_has_radial_velocity();
}
 double RadarDetection::radial_velocity() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.radial_velocity)
  return radial_velocity_;
}
 void RadarDetection::set_radial_velocity(double value) {
  set_has_radial_velocity();
  radial_velocity_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.radial_velocity)
}

// optional double radial_velocity_rmse = 6;
bool RadarDetection::has_radial_velocity_rmse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RadarDetection::set_has_radial_velocity_rmse() {
  _has_bits_[0] |= 0x00000020u;
}
void RadarDetection::clear_has_radial_velocity_rmse() {
  _has_bits_[0] &= ~0x00000020u;
}
void RadarDetection::clear_radial_velocity_rmse() {
  radial_velocity_rmse_ = 0;
  clear_has_radial_velocity_rmse();
}
 double RadarDetection::radial_velocity_rmse() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.radial_velocity_rmse)
  return radial_velocity_rmse_;
}
 void RadarDetection::set_radial_velocity_rmse(double value) {
  set_has_radial_velocity_rmse();
  radial_velocity_rmse_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.radial_velocity_rmse)
}

// optional double rcs = 7;
bool RadarDetection::has_rcs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void RadarDetection::set_has_rcs() {
  _has_bits_[0] |= 0x00000040u;
}
void RadarDetection::clear_has_rcs() {
  _has_bits_[0] &= ~0x00000040u;
}
void RadarDetection::clear_rcs() {
  rcs_ = 0;
  clear_has_rcs();
}
 double RadarDetection::rcs() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.rcs)
  return rcs_;
}
 void RadarDetection::set_rcs(double value) {
  set_has_rcs();
  rcs_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.rcs)
}

// optional double snr = 8;
bool RadarDetection::has_snr() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void RadarDetection::set_has_snr() {
  _has_bits_[0] |= 0x00000080u;
}
void RadarDetection::clear_has_snr() {
  _has_bits_[0] &= ~0x00000080u;
}
void RadarDetection::clear_snr() {
  snr_ = 0;
  clear_has_snr();
}
 double RadarDetection::snr() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.snr)
  return snr_;
}
 void RadarDetection::set_snr(double value) {
  set_has_snr();
  snr_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.snr)
}

// optional double point_target_probability = 9;
bool RadarDetection::has_point_target_probability() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void RadarDetection::set_has_point_target_probability() {
  _has_bits_[0] |= 0x00000100u;
}
void RadarDetection::clear_has_point_target_probability() {
  _has_bits_[0] &= ~0x00000100u;
}
void RadarDetection::clear_point_target_probability() {
  point_target_probability_ = 0;
  clear_has_point_target_probability();
}
 double RadarDetection::point_target_probability() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.point_target_probability)
  return point_target_probability_;
}
 void RadarDetection::set_point_target_probability(double value) {
  set_has_point_target_probability();
  point_target_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.point_target_probability)
}

// optional .osi3.Identifier ambiguity_id = 10;
bool RadarDetection::has_ambiguity_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void RadarDetection::set_has_ambiguity_id() {
  _has_bits_[0] |= 0x00000200u;
}
void RadarDetection::clear_has_ambiguity_id() {
  _has_bits_[0] &= ~0x00000200u;
}
void RadarDetection::clear_ambiguity_id() {
  if (ambiguity_id_ != NULL) ambiguity_id_->::osi3::Identifier::Clear();
  clear_has_ambiguity_id();
}
const ::osi3::Identifier& RadarDetection::ambiguity_id() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.ambiguity_id)
  return ambiguity_id_ != NULL ? *ambiguity_id_ : *default_instance_->ambiguity_id_;
}
::osi3::Identifier* RadarDetection::mutable_ambiguity_id() {
  set_has_ambiguity_id();
  if (ambiguity_id_ == NULL) {
    ambiguity_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.ambiguity_id)
  return ambiguity_id_;
}
::osi3::Identifier* RadarDetection::release_ambiguity_id() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.ambiguity_id)
  clear_has_ambiguity_id();
  ::osi3::Identifier* temp = ambiguity_id_;
  ambiguity_id_ = NULL;
  return temp;
}
void RadarDetection::set_allocated_ambiguity_id(::osi3::Identifier* ambiguity_id) {
  delete ambiguity_id_;
  ambiguity_id_ = ambiguity_id;
  if (ambiguity_id) {
    set_has_ambiguity_id();
  } else {
    clear_has_ambiguity_id();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.ambiguity_id)
}

// optional .osi3.DetectionClassification classification = 11;
bool RadarDetection::has_classification() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void RadarDetection::set_has_classification() {
  _has_bits_[0] |= 0x00000400u;
}
void RadarDetection::clear_has_classification() {
  _has_bits_[0] &= ~0x00000400u;
}
void RadarDetection::clear_classification() {
  classification_ = 0;
  clear_has_classification();
}
 ::osi3::DetectionClassification RadarDetection::classification() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.classification)
  return static_cast< ::osi3::DetectionClassification >(classification_);
}
 void RadarDetection::set_classification(::osi3::DetectionClassification value) {
  assert(::osi3::DetectionClassification_IsValid(value));
  set_has_classification();
  classification_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.classification)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LidarDetectionData::kHeaderFieldNumber;
const int LidarDetectionData::kDetectionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LidarDetectionData::LidarDetectionData()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.LidarDetectionData)
}

void LidarDetectionData::InitAsDefaultInstance() {
  header_ = const_cast< ::osi3::SensorDetectionHeader*>(&::osi3::SensorDetectionHeader::default_instance());
}

LidarDetectionData::LidarDetectionData(const LidarDetectionData& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.LidarDetectionData)
}

void LidarDetectionData::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LidarDetectionData::~LidarDetectionData() {
  // @@protoc_insertion_point(destructor:osi3.LidarDetectionData)
  SharedDtor();
}

void LidarDetectionData::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void LidarDetectionData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LidarDetectionData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LidarDetectionData_descriptor_;
}

const LidarDetectionData& LidarDetectionData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5ffeaturedata_2eproto();
  return *default_instance_;
}

LidarDetectionData* LidarDetectionData::default_instance_ = NULL;

LidarDetectionData* LidarDetectionData::New(::google::protobuf::Arena* arena) const {
  LidarDetectionData* n = new LidarDetectionData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LidarDetectionData::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LidarDetectionData)
  if (has_header()) {
    if (header_ != NULL) header_->::osi3::SensorDetectionHeader::Clear();
  }
  detection_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LidarDetectionData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.LidarDetectionData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.SensorDetectionHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_detection;
        break;
      }

      // repeated .osi3.LidarDetection detection = 2;
      case 2: {
        if (tag == 18) {
         parse_detection:
          DO_(input->IncrementRecursionDepth());
         parse_loop_detection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_detection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_detection;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.LidarDetectionData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.LidarDetectionData)
  return false;
#undef DO_
}

void LidarDetectionData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.LidarDetectionData)
  // optional .osi3.SensorDetectionHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // repeated .osi3.LidarDetection detection = 2;
  for (unsigned int i = 0, n = this->detection_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->detection(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.LidarDetectionData)
}

::google::protobuf::uint8* LidarDetectionData::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.LidarDetectionData)
  // optional .osi3.SensorDetectionHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, false, target);
  }

  // repeated .osi3.LidarDetection detection = 2;
  for (unsigned int i = 0, n = this->detection_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->detection(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.LidarDetectionData)
  return target;
}

int LidarDetectionData::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.LidarDetectionData)
  int total_size = 0;

  // optional .osi3.SensorDetectionHeader header = 1;
  if (has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // repeated .osi3.LidarDetection detection = 2;
  total_size += 1 * this->detection_size();
  for (int i = 0; i < this->detection_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->detection(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LidarDetectionData::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.LidarDetectionData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LidarDetectionData* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LidarDetectionData>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.LidarDetectionData)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.LidarDetectionData)
    MergeFrom(*source);
  }
}

void LidarDetectionData::MergeFrom(const LidarDetectionData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.LidarDetectionData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  detection_.MergeFrom(from.detection_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::osi3::SensorDetectionHeader::MergeFrom(from.header());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LidarDetectionData::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.LidarDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LidarDetectionData::CopyFrom(const LidarDetectionData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LidarDetectionData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LidarDetectionData::IsInitialized() const {

  return true;
}

void LidarDetectionData::Swap(LidarDetectionData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LidarDetectionData::InternalSwap(LidarDetectionData* other) {
  std::swap(header_, other->header_);
  detection_.UnsafeArenaSwap(&other->detection_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LidarDetectionData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LidarDetectionData_descriptor_;
  metadata.reflection = LidarDetectionData_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LidarDetectionData

// optional .osi3.SensorDetectionHeader header = 1;
bool LidarDetectionData::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LidarDetectionData::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void LidarDetectionData::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void LidarDetectionData::clear_header() {
  if (header_ != NULL) header_->::osi3::SensorDetectionHeader::Clear();
  clear_has_header();
}
const ::osi3::SensorDetectionHeader& LidarDetectionData::header() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetectionData.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
::osi3::SensorDetectionHeader* LidarDetectionData::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::osi3::SensorDetectionHeader;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetectionData.header)
  return header_;
}
::osi3::SensorDetectionHeader* LidarDetectionData::release_header() {
  // @@protoc_insertion_point(field_release:osi3.LidarDetectionData.header)
  clear_has_header();
  ::osi3::SensorDetectionHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void LidarDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetectionData.header)
}

// repeated .osi3.LidarDetection detection = 2;
int LidarDetectionData::detection_size() const {
  return detection_.size();
}
void LidarDetectionData::clear_detection() {
  detection_.Clear();
}
const ::osi3::LidarDetection& LidarDetectionData::detection(int index) const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetectionData.detection)
  return detection_.Get(index);
}
::osi3::LidarDetection* LidarDetectionData::mutable_detection(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetectionData.detection)
  return detection_.Mutable(index);
}
::osi3::LidarDetection* LidarDetectionData::add_detection() {
  // @@protoc_insertion_point(field_add:osi3.LidarDetectionData.detection)
  return detection_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::LidarDetection >*
LidarDetectionData::mutable_detection() {
  // @@protoc_insertion_point(field_mutable_list:osi3.LidarDetectionData.detection)
  return &detection_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::LidarDetection >&
LidarDetectionData::detection() const {
  // @@protoc_insertion_point(field_list:osi3.LidarDetectionData.detection)
  return detection_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LidarDetection::kExistenceProbabilityFieldNumber;
const int LidarDetection::kObjectIdFieldNumber;
const int LidarDetection::kPositionFieldNumber;
const int LidarDetection::kPositionRmseFieldNumber;
const int LidarDetection::kHeightFieldNumber;
const int LidarDetection::kHeightRmseFieldNumber;
const int LidarDetection::kIntensityFieldNumber;
const int LidarDetection::kFreeSpaceProbabilityFieldNumber;
const int LidarDetection::kClassificationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LidarDetection::LidarDetection()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.LidarDetection)
}

void LidarDetection::InitAsDefaultInstance() {
  object_id_ = const_cast< ::osi3::Identifier*>(&::osi3::Identifier::default_instance());
  position_ = const_cast< ::osi3::Spherical3d*>(&::osi3::Spherical3d::default_instance());
  position_rmse_ = const_cast< ::osi3::Spherical3d*>(&::osi3::Spherical3d::default_instance());
}

LidarDetection::LidarDetection(const LidarDetection& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.LidarDetection)
}

void LidarDetection::SharedCtor() {
  _cached_size_ = 0;
  existence_probability_ = 0;
  object_id_ = NULL;
  position_ = NULL;
  position_rmse_ = NULL;
  height_ = 0;
  height_rmse_ = 0;
  intensity_ = 0;
  free_space_probability_ = 0;
  classification_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LidarDetection::~LidarDetection() {
  // @@protoc_insertion_point(destructor:osi3.LidarDetection)
  SharedDtor();
}

void LidarDetection::SharedDtor() {
  if (this != default_instance_) {
    delete object_id_;
    delete position_;
    delete position_rmse_;
  }
}

void LidarDetection::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LidarDetection::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LidarDetection_descriptor_;
}

const LidarDetection& LidarDetection::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5ffeaturedata_2eproto();
  return *default_instance_;
}

LidarDetection* LidarDetection::default_instance_ = NULL;

LidarDetection* LidarDetection::New(::google::protobuf::Arena* arena) const {
  LidarDetection* n = new LidarDetection;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LidarDetection::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LidarDetection)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(LidarDetection, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<LidarDetection*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(height_, free_space_probability_);
    existence_probability_ = 0;
    if (has_object_id()) {
      if (object_id_ != NULL) object_id_->::osi3::Identifier::Clear();
    }
    if (has_position()) {
      if (position_ != NULL) position_->::osi3::Spherical3d::Clear();
    }
    if (has_position_rmse()) {
      if (position_rmse_ != NULL) position_rmse_->::osi3::Spherical3d::Clear();
    }
  }
  classification_ = 0;

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LidarDetection::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.LidarDetection)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double existence_probability = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &existence_probability_)));
          set_has_existence_probability();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_object_id;
        break;
      }

      // optional .osi3.Identifier object_id = 2;
      case 2: {
        if (tag == 18) {
         parse_object_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_object_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_position;
        break;
      }

      // optional .osi3.Spherical3d position = 3;
      case 3: {
        if (tag == 26) {
         parse_position:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_position_rmse;
        break;
      }

      // optional .osi3.Spherical3d position_rmse = 4;
      case 4: {
        if (tag == 34) {
         parse_position_rmse:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position_rmse()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_height;
        break;
      }

      // optional double height = 5;
      case 5: {
        if (tag == 41) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_height_rmse;
        break;
      }

      // optional double height_rmse = 6;
      case 6: {
        if (tag == 49) {
         parse_height_rmse:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &height_rmse_)));
          set_has_height_rmse();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(57)) goto parse_intensity;
        break;
      }

      // optional double intensity = 7;
      case 7: {
        if (tag == 57) {
         parse_intensity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &intensity_)));
          set_has_intensity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(65)) goto parse_free_space_probability;
        break;
      }

      // optional double free_space_probability = 8;
      case 8: {
        if (tag == 65) {
         parse_free_space_probability:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &free_space_probability_)));
          set_has_free_space_probability();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_classification;
        break;
      }

      // optional .osi3.DetectionClassification classification = 9;
      case 9: {
        if (tag == 72) {
         parse_classification:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::osi3::DetectionClassification_IsValid(value)) {
            set_classification(static_cast< ::osi3::DetectionClassification >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.LidarDetection)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.LidarDetection)
  return false;
#undef DO_
}

void LidarDetection::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.LidarDetection)
  // optional double existence_probability = 1;
  if (has_existence_probability()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->existence_probability(), output);
  }

  // optional .osi3.Identifier object_id = 2;
  if (has_object_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->object_id_, output);
  }

  // optional .osi3.Spherical3d position = 3;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->position_, output);
  }

  // optional .osi3.Spherical3d position_rmse = 4;
  if (has_position_rmse()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->position_rmse_, output);
  }

  // optional double height = 5;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->height(), output);
  }

  // optional double height_rmse = 6;
  if (has_height_rmse()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->height_rmse(), output);
  }

  // optional double intensity = 7;
  if (has_intensity()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(7, this->intensity(), output);
  }

  // optional double free_space_probability = 8;
  if (has_free_space_probability()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(8, this->free_space_probability(), output);
  }

  // optional .osi3.DetectionClassification classification = 9;
  if (has_classification()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->classification(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.LidarDetection)
}

::google::protobuf::uint8* LidarDetection::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.LidarDetection)
  // optional double existence_probability = 1;
  if (has_existence_probability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->existence_probability(), target);
  }

  // optional .osi3.Identifier object_id = 2;
  if (has_object_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->object_id_, false, target);
  }

  // optional .osi3.Spherical3d position = 3;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->position_, false, target);
  }

  // optional .osi3.Spherical3d position_rmse = 4;
  if (has_position_rmse()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->position_rmse_, false, target);
  }

  // optional double height = 5;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->height(), target);
  }

  // optional double height_rmse = 6;
  if (has_height_rmse()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->height_rmse(), target);
  }

  // optional double intensity = 7;
  if (has_intensity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(7, this->intensity(), target);
  }

  // optional double free_space_probability = 8;
  if (has_free_space_probability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(8, this->free_space_probability(), target);
  }

  // optional .osi3.DetectionClassification classification = 9;
  if (has_classification()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->classification(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.LidarDetection)
  return target;
}

int LidarDetection::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.LidarDetection)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional double existence_probability = 1;
    if (has_existence_probability()) {
      total_size += 1 + 8;
    }

    // optional .osi3.Identifier object_id = 2;
    if (has_object_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->object_id_);
    }

    // optional .osi3.Spherical3d position = 3;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->position_);
    }

    // optional .osi3.Spherical3d position_rmse = 4;
    if (has_position_rmse()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->position_rmse_);
    }

    // optional double height = 5;
    if (has_height()) {
      total_size += 1 + 8;
    }

    // optional double height_rmse = 6;
    if (has_height_rmse()) {
      total_size += 1 + 8;
    }

    // optional double intensity = 7;
    if (has_intensity()) {
      total_size += 1 + 8;
    }

    // optional double free_space_probability = 8;
    if (has_free_space_probability()) {
      total_size += 1 + 8;
    }

  }
  // optional .osi3.DetectionClassification classification = 9;
  if (has_classification()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->classification());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LidarDetection::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.LidarDetection)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LidarDetection* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LidarDetection>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.LidarDetection)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.LidarDetection)
    MergeFrom(*source);
  }
}

void LidarDetection::MergeFrom(const LidarDetection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.LidarDetection)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_existence_probability()) {
      set_existence_probability(from.existence_probability());
    }
    if (from.has_object_id()) {
      mutable_object_id()->::osi3::Identifier::MergeFrom(from.object_id());
    }
    if (from.has_position()) {
      mutable_position()->::osi3::Spherical3d::MergeFrom(from.position());
    }
    if (from.has_position_rmse()) {
      mutable_position_rmse()->::osi3::Spherical3d::MergeFrom(from.position_rmse());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_height_rmse()) {
      set_height_rmse(from.height_rmse());
    }
    if (from.has_intensity()) {
      set_intensity(from.intensity());
    }
    if (from.has_free_space_probability()) {
      set_free_space_probability(from.free_space_probability());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_classification()) {
      set_classification(from.classification());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LidarDetection::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.LidarDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LidarDetection::CopyFrom(const LidarDetection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LidarDetection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LidarDetection::IsInitialized() const {

  return true;
}

void LidarDetection::Swap(LidarDetection* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LidarDetection::InternalSwap(LidarDetection* other) {
  std::swap(existence_probability_, other->existence_probability_);
  std::swap(object_id_, other->object_id_);
  std::swap(position_, other->position_);
  std::swap(position_rmse_, other->position_rmse_);
  std::swap(height_, other->height_);
  std::swap(height_rmse_, other->height_rmse_);
  std::swap(intensity_, other->intensity_);
  std::swap(free_space_probability_, other->free_space_probability_);
  std::swap(classification_, other->classification_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LidarDetection::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LidarDetection_descriptor_;
  metadata.reflection = LidarDetection_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LidarDetection

// optional double existence_probability = 1;
bool LidarDetection::has_existence_probability() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LidarDetection::set_has_existence_probability() {
  _has_bits_[0] |= 0x00000001u;
}
void LidarDetection::clear_has_existence_probability() {
  _has_bits_[0] &= ~0x00000001u;
}
void LidarDetection::clear_existence_probability() {
  existence_probability_ = 0;
  clear_has_existence_probability();
}
 double LidarDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.existence_probability)
  return existence_probability_;
}
 void LidarDetection::set_existence_probability(double value) {
  set_has_existence_probability();
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.existence_probability)
}

// optional .osi3.Identifier object_id = 2;
bool LidarDetection::has_object_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LidarDetection::set_has_object_id() {
  _has_bits_[0] |= 0x00000002u;
}
void LidarDetection::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void LidarDetection::clear_object_id() {
  if (object_id_ != NULL) object_id_->::osi3::Identifier::Clear();
  clear_has_object_id();
}
const ::osi3::Identifier& LidarDetection::object_id() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.object_id)
  return object_id_ != NULL ? *object_id_ : *default_instance_->object_id_;
}
::osi3::Identifier* LidarDetection::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == NULL) {
    object_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetection.object_id)
  return object_id_;
}
::osi3::Identifier* LidarDetection::release_object_id() {
  // @@protoc_insertion_point(field_release:osi3.LidarDetection.object_id)
  clear_has_object_id();
  ::osi3::Identifier* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
void LidarDetection::set_allocated_object_id(::osi3::Identifier* object_id) {
  delete object_id_;
  object_id_ = object_id;
  if (object_id) {
    set_has_object_id();
  } else {
    clear_has_object_id();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetection.object_id)
}

// optional .osi3.Spherical3d position = 3;
bool LidarDetection::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void LidarDetection::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
void LidarDetection::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
void LidarDetection::clear_position() {
  if (position_ != NULL) position_->::osi3::Spherical3d::Clear();
  clear_has_position();
}
const ::osi3::Spherical3d& LidarDetection::position() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
::osi3::Spherical3d* LidarDetection::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::osi3::Spherical3d;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetection.position)
  return position_;
}
::osi3::Spherical3d* LidarDetection::release_position() {
  // @@protoc_insertion_point(field_release:osi3.LidarDetection.position)
  clear_has_position();
  ::osi3::Spherical3d* temp = position_;
  position_ = NULL;
  return temp;
}
void LidarDetection::set_allocated_position(::osi3::Spherical3d* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetection.position)
}

// optional .osi3.Spherical3d position_rmse = 4;
bool LidarDetection::has_position_rmse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void LidarDetection::set_has_position_rmse() {
  _has_bits_[0] |= 0x00000008u;
}
void LidarDetection::clear_has_position_rmse() {
  _has_bits_[0] &= ~0x00000008u;
}
void LidarDetection::clear_position_rmse() {
  if (position_rmse_ != NULL) position_rmse_->::osi3::Spherical3d::Clear();
  clear_has_position_rmse();
}
const ::osi3::Spherical3d& LidarDetection::position_rmse() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.position_rmse)
  return position_rmse_ != NULL ? *position_rmse_ : *default_instance_->position_rmse_;
}
::osi3::Spherical3d* LidarDetection::mutable_position_rmse() {
  set_has_position_rmse();
  if (position_rmse_ == NULL) {
    position_rmse_ = new ::osi3::Spherical3d;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetection.position_rmse)
  return position_rmse_;
}
::osi3::Spherical3d* LidarDetection::release_position_rmse() {
  // @@protoc_insertion_point(field_release:osi3.LidarDetection.position_rmse)
  clear_has_position_rmse();
  ::osi3::Spherical3d* temp = position_rmse_;
  position_rmse_ = NULL;
  return temp;
}
void LidarDetection::set_allocated_position_rmse(::osi3::Spherical3d* position_rmse) {
  delete position_rmse_;
  position_rmse_ = position_rmse;
  if (position_rmse) {
    set_has_position_rmse();
  } else {
    clear_has_position_rmse();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetection.position_rmse)
}

// optional double height = 5;
bool LidarDetection::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void LidarDetection::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
void LidarDetection::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
void LidarDetection::clear_height() {
  height_ = 0;
  clear_has_height();
}
 double LidarDetection::height() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.height)
  return height_;
}
 void LidarDetection::set_height(double value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.height)
}

// optional double height_rmse = 6;
bool LidarDetection::has_height_rmse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void LidarDetection::set_has_height_rmse() {
  _has_bits_[0] |= 0x00000020u;
}
void LidarDetection::clear_has_height_rmse() {
  _has_bits_[0] &= ~0x00000020u;
}
void LidarDetection::clear_height_rmse() {
  height_rmse_ = 0;
  clear_has_height_rmse();
}
 double LidarDetection::height_rmse() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.height_rmse)
  return height_rmse_;
}
 void LidarDetection::set_height_rmse(double value) {
  set_has_height_rmse();
  height_rmse_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.height_rmse)
}

// optional double intensity = 7;
bool LidarDetection::has_intensity() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void LidarDetection::set_has_intensity() {
  _has_bits_[0] |= 0x00000040u;
}
void LidarDetection::clear_has_intensity() {
  _has_bits_[0] &= ~0x00000040u;
}
void LidarDetection::clear_intensity() {
  intensity_ = 0;
  clear_has_intensity();
}
 double LidarDetection::intensity() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.intensity)
  return intensity_;
}
 void LidarDetection::set_intensity(double value) {
  set_has_intensity();
  intensity_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.intensity)
}

// optional double free_space_probability = 8;
bool LidarDetection::has_free_space_probability() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void LidarDetection::set_has_free_space_probability() {
  _has_bits_[0] |= 0x00000080u;
}
void LidarDetection::clear_has_free_space_probability() {
  _has_bits_[0] &= ~0x00000080u;
}
void LidarDetection::clear_free_space_probability() {
  free_space_probability_ = 0;
  clear_has_free_space_probability();
}
 double LidarDetection::free_space_probability() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.free_space_probability)
  return free_space_probability_;
}
 void LidarDetection::set_free_space_probability(double value) {
  set_has_free_space_probability();
  free_space_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.free_space_probability)
}

// optional .osi3.DetectionClassification classification = 9;
bool LidarDetection::has_classification() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void LidarDetection::set_has_classification() {
  _has_bits_[0] |= 0x00000100u;
}
void LidarDetection::clear_has_classification() {
  _has_bits_[0] &= ~0x00000100u;
}
void LidarDetection::clear_classification() {
  classification_ = 0;
  clear_has_classification();
}
 ::osi3::DetectionClassification LidarDetection::classification() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.classification)
  return static_cast< ::osi3::DetectionClassification >(classification_);
}
 void LidarDetection::set_classification(::osi3::DetectionClassification value) {
  assert(::osi3::DetectionClassification_IsValid(value));
  set_has_classification();
  classification_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.classification)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace osi3

// @@protoc_insertion_point(global_scope)
