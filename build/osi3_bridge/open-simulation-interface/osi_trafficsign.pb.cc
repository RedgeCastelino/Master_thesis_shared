// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: osi_trafficsign.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "osi_trafficsign.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace osi3 {

namespace {

const ::google::protobuf::Descriptor* TrafficSignValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrafficSignValue_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TrafficSignValue_Unit_descriptor_ = NULL;
const ::google::protobuf::Descriptor* TrafficSign_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrafficSign_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrafficSign_MainSign_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrafficSign_MainSign_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrafficSign_MainSign_Classification_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrafficSign_MainSign_Classification_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TrafficSign_MainSign_Classification_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TrafficSign_MainSign_Classification_DirectionScope_descriptor_ = NULL;
const ::google::protobuf::Descriptor* TrafficSign_SupplementarySign_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrafficSign_SupplementarySign_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrafficSign_SupplementarySign_Classification_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrafficSign_SupplementarySign_Classification_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TrafficSign_SupplementarySign_Classification_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TrafficSign_Variability_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_osi_5ftrafficsign_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_osi_5ftrafficsign_2eproto() {
  protobuf_AddDesc_osi_5ftrafficsign_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "osi_trafficsign.proto");
  GOOGLE_CHECK(file != NULL);
  TrafficSignValue_descriptor_ = file->message_type(0);
  static const int TrafficSignValue_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSignValue, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSignValue, value_unit_),
  };
  TrafficSignValue_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TrafficSignValue_descriptor_,
      TrafficSignValue::default_instance_,
      TrafficSignValue_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSignValue, _has_bits_[0]),
      -1,
      -1,
      sizeof(TrafficSignValue),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSignValue, _internal_metadata_),
      -1);
  TrafficSignValue_Unit_descriptor_ = TrafficSignValue_descriptor_->enum_type(0);
  TrafficSign_descriptor_ = file->message_type(1);
  static const int TrafficSign_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign, main_sign_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign, supplementary_sign_),
  };
  TrafficSign_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TrafficSign_descriptor_,
      TrafficSign::default_instance_,
      TrafficSign_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign, _has_bits_[0]),
      -1,
      -1,
      sizeof(TrafficSign),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign, _internal_metadata_),
      -1);
  TrafficSign_MainSign_descriptor_ = TrafficSign_descriptor_->nested_type(0);
  static const int TrafficSign_MainSign_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_MainSign, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_MainSign, classification_),
  };
  TrafficSign_MainSign_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TrafficSign_MainSign_descriptor_,
      TrafficSign_MainSign::default_instance_,
      TrafficSign_MainSign_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_MainSign, _has_bits_[0]),
      -1,
      -1,
      sizeof(TrafficSign_MainSign),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_MainSign, _internal_metadata_),
      -1);
  TrafficSign_MainSign_Classification_descriptor_ = TrafficSign_MainSign_descriptor_->nested_type(0);
  static const int TrafficSign_MainSign_Classification_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_MainSign_Classification, variability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_MainSign_Classification, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_MainSign_Classification, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_MainSign_Classification, direction_scope_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_MainSign_Classification, assigned_lane_id_),
  };
  TrafficSign_MainSign_Classification_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TrafficSign_MainSign_Classification_descriptor_,
      TrafficSign_MainSign_Classification::default_instance_,
      TrafficSign_MainSign_Classification_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_MainSign_Classification, _has_bits_[0]),
      -1,
      -1,
      sizeof(TrafficSign_MainSign_Classification),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_MainSign_Classification, _internal_metadata_),
      -1);
  TrafficSign_MainSign_Classification_Type_descriptor_ = TrafficSign_MainSign_Classification_descriptor_->enum_type(0);
  TrafficSign_MainSign_Classification_DirectionScope_descriptor_ = TrafficSign_MainSign_Classification_descriptor_->enum_type(1);
  TrafficSign_SupplementarySign_descriptor_ = TrafficSign_descriptor_->nested_type(1);
  static const int TrafficSign_SupplementarySign_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_SupplementarySign, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_SupplementarySign, classification_),
  };
  TrafficSign_SupplementarySign_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TrafficSign_SupplementarySign_descriptor_,
      TrafficSign_SupplementarySign::default_instance_,
      TrafficSign_SupplementarySign_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_SupplementarySign, _has_bits_[0]),
      -1,
      -1,
      sizeof(TrafficSign_SupplementarySign),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_SupplementarySign, _internal_metadata_),
      -1);
  TrafficSign_SupplementarySign_Classification_descriptor_ = TrafficSign_SupplementarySign_descriptor_->nested_type(0);
  static const int TrafficSign_SupplementarySign_Classification_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_SupplementarySign_Classification, variability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_SupplementarySign_Classification, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_SupplementarySign_Classification, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_SupplementarySign_Classification, assigned_lane_id_),
  };
  TrafficSign_SupplementarySign_Classification_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TrafficSign_SupplementarySign_Classification_descriptor_,
      TrafficSign_SupplementarySign_Classification::default_instance_,
      TrafficSign_SupplementarySign_Classification_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_SupplementarySign_Classification, _has_bits_[0]),
      -1,
      -1,
      sizeof(TrafficSign_SupplementarySign_Classification),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficSign_SupplementarySign_Classification, _internal_metadata_),
      -1);
  TrafficSign_SupplementarySign_Classification_Type_descriptor_ = TrafficSign_SupplementarySign_Classification_descriptor_->enum_type(0);
  TrafficSign_Variability_descriptor_ = TrafficSign_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_osi_5ftrafficsign_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TrafficSignValue_descriptor_, &TrafficSignValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TrafficSign_descriptor_, &TrafficSign::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TrafficSign_MainSign_descriptor_, &TrafficSign_MainSign::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TrafficSign_MainSign_Classification_descriptor_, &TrafficSign_MainSign_Classification::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TrafficSign_SupplementarySign_descriptor_, &TrafficSign_SupplementarySign::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TrafficSign_SupplementarySign_Classification_descriptor_, &TrafficSign_SupplementarySign_Classification::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_osi_5ftrafficsign_2eproto() {
  delete TrafficSignValue::default_instance_;
  delete TrafficSignValue_reflection_;
  delete TrafficSign::default_instance_;
  delete TrafficSign_reflection_;
  delete TrafficSign_MainSign::default_instance_;
  delete TrafficSign_MainSign_reflection_;
  delete TrafficSign_MainSign_Classification::default_instance_;
  delete TrafficSign_MainSign_Classification_reflection_;
  delete TrafficSign_SupplementarySign::default_instance_;
  delete TrafficSign_SupplementarySign_reflection_;
  delete TrafficSign_SupplementarySign_Classification::default_instance_;
  delete TrafficSign_SupplementarySign_Classification_reflection_;
}

void protobuf_AddDesc_osi_5ftrafficsign_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_osi_5ftrafficsign_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::osi3::protobuf_AddDesc_osi_5fcommon_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\025osi_trafficsign.proto\022\004osi3\032\020osi_commo"
    "n.proto\"\367\002\n\020TrafficSignValue\022\r\n\005value\030\001 "
    "\001(\001\022/\n\nvalue_unit\030\002 \001(\0162\033.osi3.TrafficSi"
    "gnValue.Unit\"\242\002\n\004Unit\022\020\n\014UNIT_UNKNOWN\020\000\022"
    "\016\n\nUNIT_OTHER\020\001\022\020\n\014UNIT_NO_UNIT\020\002\022\033\n\027UNI"
    "T_KILOMETER_PER_HOUR\020\003\022\026\n\022UNIT_MILE_PER_"
    "HOUR\020\004\022\016\n\nUNIT_METER\020\005\022\022\n\016UNIT_KILOMETER"
    "\020\006\022\r\n\tUNIT_FEET\020\007\022\r\n\tUNIT_MILE\020\010\022\023\n\017UNIT"
    "_METRIC_TON\020\t\022\021\n\rUNIT_LONG_TON\020\n\022\022\n\016UNIT"
    "_SHORT_TON\020\013\022\020\n\014UNIT_MINUTES\020\014\022\014\n\010UNIT_D"
    "AY\020\r\022\023\n\017UNIT_PERCENTAGE\020\016\"\243$\n\013TrafficSig"
    "n\022\034\n\002id\030\001 \001(\0132\020.osi3.Identifier\022-\n\tmain_"
    "sign\030\002 \001(\0132\032.osi3.TrafficSign.MainSign\022\?"
    "\n\022supplementary_sign\030\003 \003(\0132#.osi3.Traffi"
    "cSign.SupplementarySign\032\225\033\n\010MainSign\022\"\n\004"
    "base\030\001 \001(\0132\024.osi3.BaseStationary\022A\n\016clas"
    "sification\030\002 \001(\0132).osi3.TrafficSign.Main"
    "Sign.Classification\032\241\032\n\016Classification\0222"
    "\n\013variability\030\001 \001(\0162\035.osi3.TrafficSign.V"
    "ariability\022<\n\004type\030\002 \001(\0162..osi3.TrafficS"
    "ign.MainSign.Classification.Type\022%\n\005valu"
    "e\030\003 \001(\0132\026.osi3.TrafficSignValue\022Q\n\017direc"
    "tion_scope\030\004 \001(\01628.osi3.TrafficSign.Main"
    "Sign.Classification.DirectionScope\022*\n\020as"
    "signed_lane_id\030\005 \003(\0132\020.osi3.Identifier\"\264"
    "\026\n\004Type\022\020\n\014TYPE_UNKNOWN\020\000\022\016\n\nTYPE_OTHER\020"
    "\001\022\024\n\020TYPE_DANGER_SPOT\020\002\022,\n(TYPE_RIGHT_BE"
    "FORE_LEFT_NEXT_INTERSECTION\020\003\022\022\n\016TYPE_TU"
    "RN_LEFT\020\004\022\023\n\017TYPE_TURN_RIGHT\020\005\022\031\n\025TYPE_D"
    "OUBLE_TURN_LEFT\020\006\022\032\n\026TYPE_DOUBLE_TURN_RI"
    "GHT\020\007\022\027\n\023TYPE_HILL_DOWNWARDS\020\010\022\025\n\021TYPE_H"
    "ILL_UPWARDS\020\t\022\037\n\033TYPE_WARNING_ROAD_NARRO"
    "WING\020\n\022$\n TYPE_WARNING_ROAD_NARROWING_LE"
    "FT\020\013\022%\n!TYPE_WARNING_ROAD_NARROWING_RIGH"
    "T\020\014\022\023\n\017TYPE_ROAD_WORKS\020\r\022 \n\034TYPE_WARNING"
    "_TWO_WAY_TRAFFIC\020\016\022 \n\034TYPE_ATTENTION_TRA"
    "FFIC_LIGHT\020\017\022\021\n\rTYPE_GIVE_WAY\020\020\022\r\n\tTYPE_"
    "STOP\020\021\022\'\n#TYPE_PRIORITY_TO_OPPOSITE_DIRE"
    "CTION\020\022\0223\n/TYPE_PRIORITY_TO_OPPOSITE_DIR"
    "ECTION_UPSIDE_DOWN\020\023\022\035\n\031TYPE_PRESCRIBED_"
    "LEFT_TURN\020\024\022\036\n\032TYPE_PRESCRIBED_RIGHT_TUR"
    "N\020\025\022\"\n\036TYPE_PRESCRIBED_STRAIGHT_AHEAD\020\026\022"
    "\034\n\030TYPE_PRESCRIBED_LEFT_WAY\020\027\022\035\n\031TYPE_PR"
    "ESCRIBED_RIGHT_WAY\020\030\0220\n,TYPE_PRESCRIBED_"
    "LEFT_TURN_AND_STRAIGHT_AHEAD\020\031\0221\n-TYPE_P"
    "RESCRIBED_RIGHT_TURN_AND_STRAIGHT_AHEAD\020"
    "\032\022,\n(TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT"
    "_TURN\020\033\022;\n7TYPE_PRESCRIBED_LEFT_TURN_RIG"
    "HT_TURN_AND_STRAIGHT_AHEAD\020\034\022\023\n\017TYPE_ROU"
    "NDABOUT\020\035\022\024\n\020TYPE_ONEWAY_LEFT\020\036\022\025\n\021TYPE_"
    "ONEWAY_RIGHT\020\037\022\022\n\016TYPE_PASS_LEFT\020 \022\023\n\017TY"
    "PE_PASS_RIGHT\020!\022\021\n\rTYPE_BUS_LANE\020\"\022\027\n\023TY"
    "PE_BUS_LANE_BEGIN\020#\022\025\n\021TYPE_BUS_LANE_END"
    "\020$\022\033\n\027TYPE_PROHIBITED_FOR_ALL\020%\022&\n\"TYPE_"
    "PROHIBITED_FOR_MOTOR_VEHICLES\020&\022\036\n\032TYPE_"
    "PROHIBITED_FOR_TRUCKS\020\'\022 \n\034TYPE_PROHIBIT"
    "ED_FOR_BICYCLES\020(\022\'\n#TYPE_PROHIBITED_FOR"
    "_MOTOR_AND_BIKES\020)\022#\n\037TYPE_PROHIBITED_FO"
    "R_PEDESTRIANS\020*\022,\n(TYPE_PROHIBITED_FOR_M"
    "OTOR_VEHICLES_BIKES\020+\022\025\n\021TYPE_DO_NOT_ENT"
    "ER\020,\022!\n\035TYPE_ENVIRONMENTAL_ZONE_BEGIN\020-\022"
    "\037\n\033TYPE_ENVIRONMENTAL_ZONE_END\020.\022\027\n\023TYPE"
    "_NO_U_TURN_LEFT\020/\022\030\n\024TYPE_NO_U_TURN_RIGH"
    "T\0200\022\037\n\033TYPE_PRESCRIBED_U_TURN_LEFT\0201\022 \n\034"
    "TYPE_PRESCRIBED_U_TURN_RIGHT\0202\022$\n TYPE_M"
    "INIMUM_DISTANCE_FOR_TRUCKS\0203\022\032\n\026TYPE_SPE"
    "ED_LIMIT_BEGIN\0204\022\037\n\033TYPE_SPEED_LIMIT_ZON"
    "E_BEGIN\0205\022\035\n\031TYPE_SPEED_LIMIT_ZONE_END\0206"
    "\022\034\n\030TYPE_MINIMUM_SPEED_BEGIN\0207\022\035\n\031TYPE_O"
    "VERTAKING_BAN_BEGIN\0208\022(\n$TYPE_OVERTAKING"
    "_BAN_FOR_TRUCKS_BEGIN\0209\022\030\n\024TYPE_SPEED_LI"
    "MIT_END\020:\022\032\n\026TYPE_MINIMUM_SPEED_END\020;\022\033\n"
    "\027TYPE_OVERTAKING_BAN_END\020<\022&\n\"TYPE_OVERT"
    "AKING_BAN_FOR_TRUCKS_END\020=\022\035\n\031TYPE_ALL_R"
    "ESTRICTIONS_END\020>\022\024\n\020TYPE_NO_STOPPING\020\?\022"
    "\023\n\017TYPE_NO_PARKING\020@\022\036\n\032TYPE_NO_PARKING_"
    "ZONE_BEGIN\020A\022\034\n\030TYPE_NO_PARKING_ZONE_END"
    "\020B\022\'\n#TYPE_RIGHT_OF_WAY_NEXT_INTERSECTIO"
    "N\020C\022\033\n\027TYPE_RIGHT_OF_WAY_BEGIN\020D\022\031\n\025TYPE"
    "_RIGHT_OF_WAY_END\020E\022)\n%TYPE_PRIORITY_OVE"
    "R_OPPOSITE_DIRECTION\020F\0225\n1TYPE_PRIORITY_"
    "OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN\020G\022\023\n"
    "\017TYPE_TOWN_BEGIN\020H\022\021\n\rTYPE_TOWN_END\020I\022\024\n"
    "\020TYPE_CAR_PARKING\020J\022\037\n\033TYPE_CAR_PARKING_"
    "ZONE_BEGIN\020K\022\035\n\031TYPE_CAR_PARKING_ZONE_EN"
    "D\020L\022&\n\"TYPE_TRAFFIC_CALMED_DISTRICT_BEGI"
    "N\020M\022$\n TYPE_TRAFFIC_CALMED_DISTRICT_END\020"
    "N\022\017\n\013TYPE_TUNNEL\020O\022 \n\034TYPE_EMERGENCY_STO"
    "PPING_LEFT\020P\022!\n\035TYPE_EMERGENCY_STOPPING_"
    "RIGHT\020Q\022\026\n\022TYPE_HIGHWAY_BEGIN\020R\022\024\n\020TYPE_"
    "HIGHWAY_END\020S\022\031\n\025TYPE_EXPRESSWAY_BEGIN\020T"
    "\022\027\n\023TYPE_EXPRESSWAY_END\020U\022\025\n\021TYPE_HIGHWA"
    "Y_EXIT\020V\022!\n\035TYPE_PEDESTRIAN_CROSSING_INF"
    "O\020W\022\022\n\016TYPE_POLE_EXIT\020X\022\037\n\033TYPE_ANNOUNCE"
    "_LEFT_LANE_END\020Y\022 \n\034TYPE_ANNOUNCE_RIGHT_"
    "LANE_END\020Z\022\025\n\021TYPE_POLE_WARNING\020[\022\"\n\036TYP"
    "E_TRAFFIC_LIGHT_GREEN_ARROW\020\\\"\277\001\n\016Direct"
    "ionScope\022\033\n\027DIRECTION_SCOPE_UNKNOWN\020\000\022\031\n"
    "\025DIRECTION_SCOPE_OTHER\020\001\022 \n\034DIRECTION_SC"
    "OPE_NO_DIRECTION\020\002\022\030\n\024DIRECTION_SCOPE_LE"
    "FT\020\003\022\031\n\025DIRECTION_SCOPE_RIGHT\020\004\022\036\n\032DIREC"
    "TION_SCOPE_LEFT_RIGHT\020\005\032\375\006\n\021Supplementar"
    "ySign\022\"\n\004base\030\001 \001(\0132\024.osi3.BaseStationar"
    "y\022J\n\016classification\030\002 \001(\01322.osi3.Traffic"
    "Sign.SupplementarySign.Classification\032\367\005"
    "\n\016Classification\0222\n\013variability\030\001 \001(\0162\035."
    "osi3.TrafficSign.Variability\022E\n\004type\030\002 \001"
    "(\01627.osi3.TrafficSign.SupplementarySign."
    "Classification.Type\022%\n\005value\030\003 \003(\0132\026.osi"
    "3.TrafficSignValue\022*\n\020assigned_lane_id\030\004"
    " \003(\0132\020.osi3.Identifier\"\226\004\n\004Type\022\020\n\014TYPE_"
    "UNKNOWN\020\000\022\016\n\nTYPE_OTHER\020\001\022\020\n\014TYPE_NO_SIG"
    "N\020\002\022\033\n\027TYPE_VALID_FOR_DISTANCE\020\003\022\032\n\026TYPE"
    "_VALID_IN_DISTANCE\020\004\022\023\n\017TYPE_TIME_RANGE\020"
    "\005\022\017\n\013TYPE_WEIGHT\020\006\022\r\n\tTYPE_RAIN\020\007\022\014\n\010TYP"
    "E_FOG\020\010\022\r\n\tTYPE_SNOW\020\t\022\022\n\016TYPE_SNOW_RAIN"
    "\020\n\022\023\n\017TYPE_LEFT_ARROW\020\013\022\024\n\020TYPE_RIGHT_AR"
    "ROW\020\014\022\030\n\024TYPE_LEFT_BEND_ARROW\020\r\022\031\n\025TYPE_"
    "RIGHT_BEND_ARROW\020\016\022\016\n\nTYPE_TRUCK\020\017\022\037\n\033TY"
    "PE_TRACTORS_MAY_BE_PASSED\020\020\022\022\n\016TYPE_HAZA"
    "RDOUS\020\021\022\020\n\014TYPE_TRAILER\020\022\022\016\n\nTYPE_NIGHT\020"
    "\023\022\r\n\tTYPE_ZONE\020\024\022\023\n\017TYPE_STOP_4_WAY\020\025\022\023\n"
    "\017TYPE_MOTORCYCLE\020\026\022\033\n\027TYPE_MOTORCYCLE_AL"
    "LOWED\020\027\022\014\n\010TYPE_CAR\020\030\022\020\n\014TYPE_STOP_IN\020\031\""
    "n\n\013Variability\022\027\n\023VARIABILITY_UNKNOWN\020\000\022"
    "\025\n\021VARIABILITY_OTHER\020\001\022\025\n\021VARIABILITY_FI"
    "XED\020\002\022\030\n\024VARIABILITY_VARIABLE\020\003B\002H\001", 5075);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "osi_trafficsign.proto", &protobuf_RegisterTypes);
  TrafficSignValue::default_instance_ = new TrafficSignValue();
  TrafficSign::default_instance_ = new TrafficSign();
  TrafficSign_MainSign::default_instance_ = new TrafficSign_MainSign();
  TrafficSign_MainSign_Classification::default_instance_ = new TrafficSign_MainSign_Classification();
  TrafficSign_SupplementarySign::default_instance_ = new TrafficSign_SupplementarySign();
  TrafficSign_SupplementarySign_Classification::default_instance_ = new TrafficSign_SupplementarySign_Classification();
  TrafficSignValue::default_instance_->InitAsDefaultInstance();
  TrafficSign::default_instance_->InitAsDefaultInstance();
  TrafficSign_MainSign::default_instance_->InitAsDefaultInstance();
  TrafficSign_MainSign_Classification::default_instance_->InitAsDefaultInstance();
  TrafficSign_SupplementarySign::default_instance_->InitAsDefaultInstance();
  TrafficSign_SupplementarySign_Classification::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_osi_5ftrafficsign_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_osi_5ftrafficsign_2eproto {
  StaticDescriptorInitializer_osi_5ftrafficsign_2eproto() {
    protobuf_AddDesc_osi_5ftrafficsign_2eproto();
  }
} static_descriptor_initializer_osi_5ftrafficsign_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* TrafficSignValue_Unit_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSignValue_Unit_descriptor_;
}
bool TrafficSignValue_Unit_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TrafficSignValue_Unit TrafficSignValue::UNIT_UNKNOWN;
const TrafficSignValue_Unit TrafficSignValue::UNIT_OTHER;
const TrafficSignValue_Unit TrafficSignValue::UNIT_NO_UNIT;
const TrafficSignValue_Unit TrafficSignValue::UNIT_KILOMETER_PER_HOUR;
const TrafficSignValue_Unit TrafficSignValue::UNIT_MILE_PER_HOUR;
const TrafficSignValue_Unit TrafficSignValue::UNIT_METER;
const TrafficSignValue_Unit TrafficSignValue::UNIT_KILOMETER;
const TrafficSignValue_Unit TrafficSignValue::UNIT_FEET;
const TrafficSignValue_Unit TrafficSignValue::UNIT_MILE;
const TrafficSignValue_Unit TrafficSignValue::UNIT_METRIC_TON;
const TrafficSignValue_Unit TrafficSignValue::UNIT_LONG_TON;
const TrafficSignValue_Unit TrafficSignValue::UNIT_SHORT_TON;
const TrafficSignValue_Unit TrafficSignValue::UNIT_MINUTES;
const TrafficSignValue_Unit TrafficSignValue::UNIT_DAY;
const TrafficSignValue_Unit TrafficSignValue::UNIT_PERCENTAGE;
const TrafficSignValue_Unit TrafficSignValue::Unit_MIN;
const TrafficSignValue_Unit TrafficSignValue::Unit_MAX;
const int TrafficSignValue::Unit_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficSignValue::kValueFieldNumber;
const int TrafficSignValue::kValueUnitFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficSignValue::TrafficSignValue()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.TrafficSignValue)
}

void TrafficSignValue::InitAsDefaultInstance() {
}

TrafficSignValue::TrafficSignValue(const TrafficSignValue& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.TrafficSignValue)
}

void TrafficSignValue::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0;
  value_unit_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrafficSignValue::~TrafficSignValue() {
  // @@protoc_insertion_point(destructor:osi3.TrafficSignValue)
  SharedDtor();
}

void TrafficSignValue::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TrafficSignValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrafficSignValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSignValue_descriptor_;
}

const TrafficSignValue& TrafficSignValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5ftrafficsign_2eproto();
  return *default_instance_;
}

TrafficSignValue* TrafficSignValue::default_instance_ = NULL;

TrafficSignValue* TrafficSignValue::New(::google::protobuf::Arena* arena) const {
  TrafficSignValue* n = new TrafficSignValue;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrafficSignValue::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.TrafficSignValue)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TrafficSignValue, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TrafficSignValue*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(value_, value_unit_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TrafficSignValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.TrafficSignValue)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double value = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_value_unit;
        break;
      }

      // optional .osi3.TrafficSignValue.Unit value_unit = 2;
      case 2: {
        if (tag == 16) {
         parse_value_unit:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::osi3::TrafficSignValue_Unit_IsValid(value)) {
            set_value_unit(static_cast< ::osi3::TrafficSignValue_Unit >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.TrafficSignValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.TrafficSignValue)
  return false;
#undef DO_
}

void TrafficSignValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.TrafficSignValue)
  // optional double value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->value(), output);
  }

  // optional .osi3.TrafficSignValue.Unit value_unit = 2;
  if (has_value_unit()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->value_unit(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.TrafficSignValue)
}

::google::protobuf::uint8* TrafficSignValue::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.TrafficSignValue)
  // optional double value = 1;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->value(), target);
  }

  // optional .osi3.TrafficSignValue.Unit value_unit = 2;
  if (has_value_unit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->value_unit(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.TrafficSignValue)
  return target;
}

int TrafficSignValue::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.TrafficSignValue)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional double value = 1;
    if (has_value()) {
      total_size += 1 + 8;
    }

    // optional .osi3.TrafficSignValue.Unit value_unit = 2;
    if (has_value_unit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->value_unit());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrafficSignValue::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.TrafficSignValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TrafficSignValue* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficSignValue>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.TrafficSignValue)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.TrafficSignValue)
    MergeFrom(*source);
  }
}

void TrafficSignValue::MergeFrom(const TrafficSignValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.TrafficSignValue)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_value_unit()) {
      set_value_unit(from.value_unit());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TrafficSignValue::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.TrafficSignValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficSignValue::CopyFrom(const TrafficSignValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.TrafficSignValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficSignValue::IsInitialized() const {

  return true;
}

void TrafficSignValue::Swap(TrafficSignValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrafficSignValue::InternalSwap(TrafficSignValue* other) {
  std::swap(value_, other->value_);
  std::swap(value_unit_, other->value_unit_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TrafficSignValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrafficSignValue_descriptor_;
  metadata.reflection = TrafficSignValue_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TrafficSignValue

// optional double value = 1;
bool TrafficSignValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TrafficSignValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void TrafficSignValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void TrafficSignValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
 double TrafficSignValue::value() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSignValue.value)
  return value_;
}
 void TrafficSignValue::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:osi3.TrafficSignValue.value)
}

// optional .osi3.TrafficSignValue.Unit value_unit = 2;
bool TrafficSignValue::has_value_unit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TrafficSignValue::set_has_value_unit() {
  _has_bits_[0] |= 0x00000002u;
}
void TrafficSignValue::clear_has_value_unit() {
  _has_bits_[0] &= ~0x00000002u;
}
void TrafficSignValue::clear_value_unit() {
  value_unit_ = 0;
  clear_has_value_unit();
}
 ::osi3::TrafficSignValue_Unit TrafficSignValue::value_unit() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSignValue.value_unit)
  return static_cast< ::osi3::TrafficSignValue_Unit >(value_unit_);
}
 void TrafficSignValue::set_value_unit(::osi3::TrafficSignValue_Unit value) {
  assert(::osi3::TrafficSignValue_Unit_IsValid(value));
  set_has_value_unit();
  value_unit_ = value;
  // @@protoc_insertion_point(field_set:osi3.TrafficSignValue.value_unit)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* TrafficSign_Variability_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSign_Variability_descriptor_;
}
bool TrafficSign_Variability_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TrafficSign_Variability TrafficSign::VARIABILITY_UNKNOWN;
const TrafficSign_Variability TrafficSign::VARIABILITY_OTHER;
const TrafficSign_Variability TrafficSign::VARIABILITY_FIXED;
const TrafficSign_Variability TrafficSign::VARIABILITY_VARIABLE;
const TrafficSign_Variability TrafficSign::Variability_MIN;
const TrafficSign_Variability TrafficSign::Variability_MAX;
const int TrafficSign::Variability_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TrafficSign_MainSign_Classification_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSign_MainSign_Classification_Type_descriptor_;
}
bool TrafficSign_MainSign_Classification_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_UNKNOWN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_OTHER;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_DANGER_SPOT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_RIGHT_BEFORE_LEFT_NEXT_INTERSECTION;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_TURN_LEFT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_TURN_RIGHT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_DOUBLE_TURN_LEFT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_DOUBLE_TURN_RIGHT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_HILL_DOWNWARDS;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_HILL_UPWARDS;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_WARNING_ROAD_NARROWING;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_WARNING_ROAD_NARROWING_LEFT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_WARNING_ROAD_NARROWING_RIGHT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_ROAD_WORKS;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_WARNING_TWO_WAY_TRAFFIC;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_ATTENTION_TRAFFIC_LIGHT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_GIVE_WAY;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_STOP;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRIORITY_TO_OPPOSITE_DIRECTION;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRIORITY_TO_OPPOSITE_DIRECTION_UPSIDE_DOWN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRESCRIBED_LEFT_TURN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRESCRIBED_RIGHT_TURN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRESCRIBED_STRAIGHT_AHEAD;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRESCRIBED_LEFT_WAY;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRESCRIBED_RIGHT_WAY;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRESCRIBED_LEFT_TURN_AND_STRAIGHT_AHEAD;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRESCRIBED_RIGHT_TURN_AND_STRAIGHT_AHEAD;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRESCRIBED_LEFT_TURN_AND_RIGHT_TURN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRESCRIBED_LEFT_TURN_RIGHT_TURN_AND_STRAIGHT_AHEAD;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_ROUNDABOUT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_ONEWAY_LEFT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_ONEWAY_RIGHT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PASS_LEFT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PASS_RIGHT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_BUS_LANE;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_BUS_LANE_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_BUS_LANE_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PROHIBITED_FOR_ALL;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PROHIBITED_FOR_MOTOR_VEHICLES;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PROHIBITED_FOR_TRUCKS;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PROHIBITED_FOR_BICYCLES;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PROHIBITED_FOR_MOTOR_AND_BIKES;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PROHIBITED_FOR_PEDESTRIANS;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PROHIBITED_FOR_MOTOR_VEHICLES_BIKES;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_DO_NOT_ENTER;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_ENVIRONMENTAL_ZONE_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_ENVIRONMENTAL_ZONE_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_NO_U_TURN_LEFT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_NO_U_TURN_RIGHT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRESCRIBED_U_TURN_LEFT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRESCRIBED_U_TURN_RIGHT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_MINIMUM_DISTANCE_FOR_TRUCKS;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_SPEED_LIMIT_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_SPEED_LIMIT_ZONE_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_SPEED_LIMIT_ZONE_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_MINIMUM_SPEED_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_OVERTAKING_BAN_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_OVERTAKING_BAN_FOR_TRUCKS_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_SPEED_LIMIT_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_MINIMUM_SPEED_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_OVERTAKING_BAN_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_OVERTAKING_BAN_FOR_TRUCKS_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_ALL_RESTRICTIONS_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_NO_STOPPING;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_NO_PARKING;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_NO_PARKING_ZONE_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_NO_PARKING_ZONE_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_RIGHT_OF_WAY_NEXT_INTERSECTION;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_RIGHT_OF_WAY_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_RIGHT_OF_WAY_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PRIORITY_OVER_OPPOSITE_DIRECTION_UPSIDE_DOWN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_TOWN_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_TOWN_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_CAR_PARKING;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_CAR_PARKING_ZONE_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_CAR_PARKING_ZONE_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_TRAFFIC_CALMED_DISTRICT_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_TRAFFIC_CALMED_DISTRICT_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_TUNNEL;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_EMERGENCY_STOPPING_LEFT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_EMERGENCY_STOPPING_RIGHT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_HIGHWAY_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_HIGHWAY_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_EXPRESSWAY_BEGIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_EXPRESSWAY_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_HIGHWAY_EXIT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_PEDESTRIAN_CROSSING_INFO;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_POLE_EXIT;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_ANNOUNCE_LEFT_LANE_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_ANNOUNCE_RIGHT_LANE_END;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_POLE_WARNING;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::TYPE_TRAFFIC_LIGHT_GREEN_ARROW;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::Type_MIN;
const TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::Type_MAX;
const int TrafficSign_MainSign_Classification::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TrafficSign_MainSign_Classification_DirectionScope_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSign_MainSign_Classification_DirectionScope_descriptor_;
}
bool TrafficSign_MainSign_Classification_DirectionScope_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::DIRECTION_SCOPE_UNKNOWN;
const TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::DIRECTION_SCOPE_OTHER;
const TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::DIRECTION_SCOPE_NO_DIRECTION;
const TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::DIRECTION_SCOPE_LEFT;
const TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::DIRECTION_SCOPE_RIGHT;
const TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::DIRECTION_SCOPE_LEFT_RIGHT;
const TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::DirectionScope_MIN;
const TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::DirectionScope_MAX;
const int TrafficSign_MainSign_Classification::DirectionScope_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficSign_MainSign_Classification::kVariabilityFieldNumber;
const int TrafficSign_MainSign_Classification::kTypeFieldNumber;
const int TrafficSign_MainSign_Classification::kValueFieldNumber;
const int TrafficSign_MainSign_Classification::kDirectionScopeFieldNumber;
const int TrafficSign_MainSign_Classification::kAssignedLaneIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficSign_MainSign_Classification::TrafficSign_MainSign_Classification()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.TrafficSign.MainSign.Classification)
}

void TrafficSign_MainSign_Classification::InitAsDefaultInstance() {
  value_ = const_cast< ::osi3::TrafficSignValue*>(&::osi3::TrafficSignValue::default_instance());
}

TrafficSign_MainSign_Classification::TrafficSign_MainSign_Classification(const TrafficSign_MainSign_Classification& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.TrafficSign.MainSign.Classification)
}

void TrafficSign_MainSign_Classification::SharedCtor() {
  _cached_size_ = 0;
  variability_ = 0;
  type_ = 0;
  value_ = NULL;
  direction_scope_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrafficSign_MainSign_Classification::~TrafficSign_MainSign_Classification() {
  // @@protoc_insertion_point(destructor:osi3.TrafficSign.MainSign.Classification)
  SharedDtor();
}

void TrafficSign_MainSign_Classification::SharedDtor() {
  if (this != default_instance_) {
    delete value_;
  }
}

void TrafficSign_MainSign_Classification::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrafficSign_MainSign_Classification::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSign_MainSign_Classification_descriptor_;
}

const TrafficSign_MainSign_Classification& TrafficSign_MainSign_Classification::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5ftrafficsign_2eproto();
  return *default_instance_;
}

TrafficSign_MainSign_Classification* TrafficSign_MainSign_Classification::default_instance_ = NULL;

TrafficSign_MainSign_Classification* TrafficSign_MainSign_Classification::New(::google::protobuf::Arena* arena) const {
  TrafficSign_MainSign_Classification* n = new TrafficSign_MainSign_Classification;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrafficSign_MainSign_Classification::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.TrafficSign.MainSign.Classification)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TrafficSign_MainSign_Classification, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TrafficSign_MainSign_Classification*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(variability_, type_);
    if (has_value()) {
      if (value_ != NULL) value_->::osi3::TrafficSignValue::Clear();
    }
    direction_scope_ = 0;
  }

#undef ZR_HELPER_
#undef ZR_

  assigned_lane_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TrafficSign_MainSign_Classification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.TrafficSign.MainSign.Classification)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.TrafficSign.Variability variability = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::osi3::TrafficSign_Variability_IsValid(value)) {
            set_variability(static_cast< ::osi3::TrafficSign_Variability >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional .osi3.TrafficSign.MainSign.Classification.Type type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::osi3::TrafficSign_MainSign_Classification_Type_IsValid(value)) {
            set_type(static_cast< ::osi3::TrafficSign_MainSign_Classification_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // optional .osi3.TrafficSignValue value = 3;
      case 3: {
        if (tag == 26) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_direction_scope;
        break;
      }

      // optional .osi3.TrafficSign.MainSign.Classification.DirectionScope direction_scope = 4;
      case 4: {
        if (tag == 32) {
         parse_direction_scope:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::osi3::TrafficSign_MainSign_Classification_DirectionScope_IsValid(value)) {
            set_direction_scope(static_cast< ::osi3::TrafficSign_MainSign_Classification_DirectionScope >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_assigned_lane_id;
        break;
      }

      // repeated .osi3.Identifier assigned_lane_id = 5;
      case 5: {
        if (tag == 42) {
         parse_assigned_lane_id:
          DO_(input->IncrementRecursionDepth());
         parse_loop_assigned_lane_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_assigned_lane_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_assigned_lane_id;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.TrafficSign.MainSign.Classification)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.TrafficSign.MainSign.Classification)
  return false;
#undef DO_
}

void TrafficSign_MainSign_Classification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.TrafficSign.MainSign.Classification)
  // optional .osi3.TrafficSign.Variability variability = 1;
  if (has_variability()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->variability(), output);
  }

  // optional .osi3.TrafficSign.MainSign.Classification.Type type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .osi3.TrafficSignValue value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->value_, output);
  }

  // optional .osi3.TrafficSign.MainSign.Classification.DirectionScope direction_scope = 4;
  if (has_direction_scope()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->direction_scope(), output);
  }

  // repeated .osi3.Identifier assigned_lane_id = 5;
  for (unsigned int i = 0, n = this->assigned_lane_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->assigned_lane_id(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.TrafficSign.MainSign.Classification)
}

::google::protobuf::uint8* TrafficSign_MainSign_Classification::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.TrafficSign.MainSign.Classification)
  // optional .osi3.TrafficSign.Variability variability = 1;
  if (has_variability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->variability(), target);
  }

  // optional .osi3.TrafficSign.MainSign.Classification.Type type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional .osi3.TrafficSignValue value = 3;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->value_, false, target);
  }

  // optional .osi3.TrafficSign.MainSign.Classification.DirectionScope direction_scope = 4;
  if (has_direction_scope()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->direction_scope(), target);
  }

  // repeated .osi3.Identifier assigned_lane_id = 5;
  for (unsigned int i = 0, n = this->assigned_lane_id_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->assigned_lane_id(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.TrafficSign.MainSign.Classification)
  return target;
}

int TrafficSign_MainSign_Classification::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.TrafficSign.MainSign.Classification)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .osi3.TrafficSign.Variability variability = 1;
    if (has_variability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->variability());
    }

    // optional .osi3.TrafficSign.MainSign.Classification.Type type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .osi3.TrafficSignValue value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

    // optional .osi3.TrafficSign.MainSign.Classification.DirectionScope direction_scope = 4;
    if (has_direction_scope()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->direction_scope());
    }

  }
  // repeated .osi3.Identifier assigned_lane_id = 5;
  total_size += 1 * this->assigned_lane_id_size();
  for (int i = 0; i < this->assigned_lane_id_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->assigned_lane_id(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrafficSign_MainSign_Classification::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.TrafficSign.MainSign.Classification)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TrafficSign_MainSign_Classification* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficSign_MainSign_Classification>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.TrafficSign.MainSign.Classification)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.TrafficSign.MainSign.Classification)
    MergeFrom(*source);
  }
}

void TrafficSign_MainSign_Classification::MergeFrom(const TrafficSign_MainSign_Classification& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.TrafficSign.MainSign.Classification)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  assigned_lane_id_.MergeFrom(from.assigned_lane_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_variability()) {
      set_variability(from.variability());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_value()) {
      mutable_value()->::osi3::TrafficSignValue::MergeFrom(from.value());
    }
    if (from.has_direction_scope()) {
      set_direction_scope(from.direction_scope());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TrafficSign_MainSign_Classification::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.TrafficSign.MainSign.Classification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficSign_MainSign_Classification::CopyFrom(const TrafficSign_MainSign_Classification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.TrafficSign.MainSign.Classification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficSign_MainSign_Classification::IsInitialized() const {

  return true;
}

void TrafficSign_MainSign_Classification::Swap(TrafficSign_MainSign_Classification* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrafficSign_MainSign_Classification::InternalSwap(TrafficSign_MainSign_Classification* other) {
  std::swap(variability_, other->variability_);
  std::swap(type_, other->type_);
  std::swap(value_, other->value_);
  std::swap(direction_scope_, other->direction_scope_);
  assigned_lane_id_.UnsafeArenaSwap(&other->assigned_lane_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TrafficSign_MainSign_Classification::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrafficSign_MainSign_Classification_descriptor_;
  metadata.reflection = TrafficSign_MainSign_Classification_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficSign_MainSign::kBaseFieldNumber;
const int TrafficSign_MainSign::kClassificationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficSign_MainSign::TrafficSign_MainSign()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.TrafficSign.MainSign)
}

void TrafficSign_MainSign::InitAsDefaultInstance() {
  base_ = const_cast< ::osi3::BaseStationary*>(&::osi3::BaseStationary::default_instance());
  classification_ = const_cast< ::osi3::TrafficSign_MainSign_Classification*>(&::osi3::TrafficSign_MainSign_Classification::default_instance());
}

TrafficSign_MainSign::TrafficSign_MainSign(const TrafficSign_MainSign& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.TrafficSign.MainSign)
}

void TrafficSign_MainSign::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  classification_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrafficSign_MainSign::~TrafficSign_MainSign() {
  // @@protoc_insertion_point(destructor:osi3.TrafficSign.MainSign)
  SharedDtor();
}

void TrafficSign_MainSign::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
    delete classification_;
  }
}

void TrafficSign_MainSign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrafficSign_MainSign::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSign_MainSign_descriptor_;
}

const TrafficSign_MainSign& TrafficSign_MainSign::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5ftrafficsign_2eproto();
  return *default_instance_;
}

TrafficSign_MainSign* TrafficSign_MainSign::default_instance_ = NULL;

TrafficSign_MainSign* TrafficSign_MainSign::New(::google::protobuf::Arena* arena) const {
  TrafficSign_MainSign* n = new TrafficSign_MainSign;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrafficSign_MainSign::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.TrafficSign.MainSign)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_base()) {
      if (base_ != NULL) base_->::osi3::BaseStationary::Clear();
    }
    if (has_classification()) {
      if (classification_ != NULL) classification_->::osi3::TrafficSign_MainSign_Classification::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TrafficSign_MainSign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.TrafficSign.MainSign)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.BaseStationary base = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_classification;
        break;
      }

      // optional .osi3.TrafficSign.MainSign.Classification classification = 2;
      case 2: {
        if (tag == 18) {
         parse_classification:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_classification()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.TrafficSign.MainSign)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.TrafficSign.MainSign)
  return false;
#undef DO_
}

void TrafficSign_MainSign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.TrafficSign.MainSign)
  // optional .osi3.BaseStationary base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->base_, output);
  }

  // optional .osi3.TrafficSign.MainSign.Classification classification = 2;
  if (has_classification()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->classification_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.TrafficSign.MainSign)
}

::google::protobuf::uint8* TrafficSign_MainSign::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.TrafficSign.MainSign)
  // optional .osi3.BaseStationary base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->base_, false, target);
  }

  // optional .osi3.TrafficSign.MainSign.Classification classification = 2;
  if (has_classification()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->classification_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.TrafficSign.MainSign)
  return target;
}

int TrafficSign_MainSign::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.TrafficSign.MainSign)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .osi3.BaseStationary base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->base_);
    }

    // optional .osi3.TrafficSign.MainSign.Classification classification = 2;
    if (has_classification()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->classification_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrafficSign_MainSign::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.TrafficSign.MainSign)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TrafficSign_MainSign* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficSign_MainSign>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.TrafficSign.MainSign)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.TrafficSign.MainSign)
    MergeFrom(*source);
  }
}

void TrafficSign_MainSign::MergeFrom(const TrafficSign_MainSign& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.TrafficSign.MainSign)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::osi3::BaseStationary::MergeFrom(from.base());
    }
    if (from.has_classification()) {
      mutable_classification()->::osi3::TrafficSign_MainSign_Classification::MergeFrom(from.classification());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TrafficSign_MainSign::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.TrafficSign.MainSign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficSign_MainSign::CopyFrom(const TrafficSign_MainSign& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.TrafficSign.MainSign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficSign_MainSign::IsInitialized() const {

  return true;
}

void TrafficSign_MainSign::Swap(TrafficSign_MainSign* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrafficSign_MainSign::InternalSwap(TrafficSign_MainSign* other) {
  std::swap(base_, other->base_);
  std::swap(classification_, other->classification_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TrafficSign_MainSign::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrafficSign_MainSign_descriptor_;
  metadata.reflection = TrafficSign_MainSign_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

const ::google::protobuf::EnumDescriptor* TrafficSign_SupplementarySign_Classification_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSign_SupplementarySign_Classification_Type_descriptor_;
}
bool TrafficSign_SupplementarySign_Classification_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_UNKNOWN;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_OTHER;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_NO_SIGN;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_VALID_FOR_DISTANCE;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_VALID_IN_DISTANCE;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_TIME_RANGE;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_WEIGHT;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_RAIN;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_FOG;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_SNOW;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_SNOW_RAIN;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_LEFT_ARROW;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_RIGHT_ARROW;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_LEFT_BEND_ARROW;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_RIGHT_BEND_ARROW;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_TRUCK;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_TRACTORS_MAY_BE_PASSED;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_HAZARDOUS;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_TRAILER;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_NIGHT;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_ZONE;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_STOP_4_WAY;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_MOTORCYCLE;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_MOTORCYCLE_ALLOWED;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_CAR;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::TYPE_STOP_IN;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::Type_MIN;
const TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::Type_MAX;
const int TrafficSign_SupplementarySign_Classification::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficSign_SupplementarySign_Classification::kVariabilityFieldNumber;
const int TrafficSign_SupplementarySign_Classification::kTypeFieldNumber;
const int TrafficSign_SupplementarySign_Classification::kValueFieldNumber;
const int TrafficSign_SupplementarySign_Classification::kAssignedLaneIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficSign_SupplementarySign_Classification::TrafficSign_SupplementarySign_Classification()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.TrafficSign.SupplementarySign.Classification)
}

void TrafficSign_SupplementarySign_Classification::InitAsDefaultInstance() {
}

TrafficSign_SupplementarySign_Classification::TrafficSign_SupplementarySign_Classification(const TrafficSign_SupplementarySign_Classification& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.TrafficSign.SupplementarySign.Classification)
}

void TrafficSign_SupplementarySign_Classification::SharedCtor() {
  _cached_size_ = 0;
  variability_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrafficSign_SupplementarySign_Classification::~TrafficSign_SupplementarySign_Classification() {
  // @@protoc_insertion_point(destructor:osi3.TrafficSign.SupplementarySign.Classification)
  SharedDtor();
}

void TrafficSign_SupplementarySign_Classification::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TrafficSign_SupplementarySign_Classification::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrafficSign_SupplementarySign_Classification::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSign_SupplementarySign_Classification_descriptor_;
}

const TrafficSign_SupplementarySign_Classification& TrafficSign_SupplementarySign_Classification::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5ftrafficsign_2eproto();
  return *default_instance_;
}

TrafficSign_SupplementarySign_Classification* TrafficSign_SupplementarySign_Classification::default_instance_ = NULL;

TrafficSign_SupplementarySign_Classification* TrafficSign_SupplementarySign_Classification::New(::google::protobuf::Arena* arena) const {
  TrafficSign_SupplementarySign_Classification* n = new TrafficSign_SupplementarySign_Classification;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrafficSign_SupplementarySign_Classification::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.TrafficSign.SupplementarySign.Classification)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TrafficSign_SupplementarySign_Classification, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TrafficSign_SupplementarySign_Classification*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(variability_, type_);

#undef ZR_HELPER_
#undef ZR_

  value_.Clear();
  assigned_lane_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TrafficSign_SupplementarySign_Classification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.TrafficSign.SupplementarySign.Classification)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.TrafficSign.Variability variability = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::osi3::TrafficSign_Variability_IsValid(value)) {
            set_variability(static_cast< ::osi3::TrafficSign_Variability >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional .osi3.TrafficSign.SupplementarySign.Classification.Type type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::osi3::TrafficSign_SupplementarySign_Classification_Type_IsValid(value)) {
            set_type(static_cast< ::osi3::TrafficSign_SupplementarySign_Classification_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // repeated .osi3.TrafficSignValue value = 3;
      case 3: {
        if (tag == 26) {
         parse_value:
          DO_(input->IncrementRecursionDepth());
         parse_loop_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_value;
        if (input->ExpectTag(34)) goto parse_loop_assigned_lane_id;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .osi3.Identifier assigned_lane_id = 4;
      case 4: {
        if (tag == 34) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_assigned_lane_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_assigned_lane_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_assigned_lane_id;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.TrafficSign.SupplementarySign.Classification)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.TrafficSign.SupplementarySign.Classification)
  return false;
#undef DO_
}

void TrafficSign_SupplementarySign_Classification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.TrafficSign.SupplementarySign.Classification)
  // optional .osi3.TrafficSign.Variability variability = 1;
  if (has_variability()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->variability(), output);
  }

  // optional .osi3.TrafficSign.SupplementarySign.Classification.Type type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // repeated .osi3.TrafficSignValue value = 3;
  for (unsigned int i = 0, n = this->value_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->value(i), output);
  }

  // repeated .osi3.Identifier assigned_lane_id = 4;
  for (unsigned int i = 0, n = this->assigned_lane_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->assigned_lane_id(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.TrafficSign.SupplementarySign.Classification)
}

::google::protobuf::uint8* TrafficSign_SupplementarySign_Classification::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.TrafficSign.SupplementarySign.Classification)
  // optional .osi3.TrafficSign.Variability variability = 1;
  if (has_variability()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->variability(), target);
  }

  // optional .osi3.TrafficSign.SupplementarySign.Classification.Type type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // repeated .osi3.TrafficSignValue value = 3;
  for (unsigned int i = 0, n = this->value_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->value(i), false, target);
  }

  // repeated .osi3.Identifier assigned_lane_id = 4;
  for (unsigned int i = 0, n = this->assigned_lane_id_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->assigned_lane_id(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.TrafficSign.SupplementarySign.Classification)
  return target;
}

int TrafficSign_SupplementarySign_Classification::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.TrafficSign.SupplementarySign.Classification)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .osi3.TrafficSign.Variability variability = 1;
    if (has_variability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->variability());
    }

    // optional .osi3.TrafficSign.SupplementarySign.Classification.Type type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  // repeated .osi3.TrafficSignValue value = 3;
  total_size += 1 * this->value_size();
  for (int i = 0; i < this->value_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->value(i));
  }

  // repeated .osi3.Identifier assigned_lane_id = 4;
  total_size += 1 * this->assigned_lane_id_size();
  for (int i = 0; i < this->assigned_lane_id_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->assigned_lane_id(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrafficSign_SupplementarySign_Classification::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.TrafficSign.SupplementarySign.Classification)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TrafficSign_SupplementarySign_Classification* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficSign_SupplementarySign_Classification>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.TrafficSign.SupplementarySign.Classification)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.TrafficSign.SupplementarySign.Classification)
    MergeFrom(*source);
  }
}

void TrafficSign_SupplementarySign_Classification::MergeFrom(const TrafficSign_SupplementarySign_Classification& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.TrafficSign.SupplementarySign.Classification)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  value_.MergeFrom(from.value_);
  assigned_lane_id_.MergeFrom(from.assigned_lane_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_variability()) {
      set_variability(from.variability());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TrafficSign_SupplementarySign_Classification::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.TrafficSign.SupplementarySign.Classification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficSign_SupplementarySign_Classification::CopyFrom(const TrafficSign_SupplementarySign_Classification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.TrafficSign.SupplementarySign.Classification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficSign_SupplementarySign_Classification::IsInitialized() const {

  return true;
}

void TrafficSign_SupplementarySign_Classification::Swap(TrafficSign_SupplementarySign_Classification* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrafficSign_SupplementarySign_Classification::InternalSwap(TrafficSign_SupplementarySign_Classification* other) {
  std::swap(variability_, other->variability_);
  std::swap(type_, other->type_);
  value_.UnsafeArenaSwap(&other->value_);
  assigned_lane_id_.UnsafeArenaSwap(&other->assigned_lane_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TrafficSign_SupplementarySign_Classification::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrafficSign_SupplementarySign_Classification_descriptor_;
  metadata.reflection = TrafficSign_SupplementarySign_Classification_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficSign_SupplementarySign::kBaseFieldNumber;
const int TrafficSign_SupplementarySign::kClassificationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficSign_SupplementarySign::TrafficSign_SupplementarySign()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.TrafficSign.SupplementarySign)
}

void TrafficSign_SupplementarySign::InitAsDefaultInstance() {
  base_ = const_cast< ::osi3::BaseStationary*>(&::osi3::BaseStationary::default_instance());
  classification_ = const_cast< ::osi3::TrafficSign_SupplementarySign_Classification*>(&::osi3::TrafficSign_SupplementarySign_Classification::default_instance());
}

TrafficSign_SupplementarySign::TrafficSign_SupplementarySign(const TrafficSign_SupplementarySign& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.TrafficSign.SupplementarySign)
}

void TrafficSign_SupplementarySign::SharedCtor() {
  _cached_size_ = 0;
  base_ = NULL;
  classification_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrafficSign_SupplementarySign::~TrafficSign_SupplementarySign() {
  // @@protoc_insertion_point(destructor:osi3.TrafficSign.SupplementarySign)
  SharedDtor();
}

void TrafficSign_SupplementarySign::SharedDtor() {
  if (this != default_instance_) {
    delete base_;
    delete classification_;
  }
}

void TrafficSign_SupplementarySign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrafficSign_SupplementarySign::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSign_SupplementarySign_descriptor_;
}

const TrafficSign_SupplementarySign& TrafficSign_SupplementarySign::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5ftrafficsign_2eproto();
  return *default_instance_;
}

TrafficSign_SupplementarySign* TrafficSign_SupplementarySign::default_instance_ = NULL;

TrafficSign_SupplementarySign* TrafficSign_SupplementarySign::New(::google::protobuf::Arena* arena) const {
  TrafficSign_SupplementarySign* n = new TrafficSign_SupplementarySign;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrafficSign_SupplementarySign::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.TrafficSign.SupplementarySign)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_base()) {
      if (base_ != NULL) base_->::osi3::BaseStationary::Clear();
    }
    if (has_classification()) {
      if (classification_ != NULL) classification_->::osi3::TrafficSign_SupplementarySign_Classification::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TrafficSign_SupplementarySign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.TrafficSign.SupplementarySign)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.BaseStationary base = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_classification;
        break;
      }

      // optional .osi3.TrafficSign.SupplementarySign.Classification classification = 2;
      case 2: {
        if (tag == 18) {
         parse_classification:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_classification()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.TrafficSign.SupplementarySign)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.TrafficSign.SupplementarySign)
  return false;
#undef DO_
}

void TrafficSign_SupplementarySign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.TrafficSign.SupplementarySign)
  // optional .osi3.BaseStationary base = 1;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->base_, output);
  }

  // optional .osi3.TrafficSign.SupplementarySign.Classification classification = 2;
  if (has_classification()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->classification_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.TrafficSign.SupplementarySign)
}

::google::protobuf::uint8* TrafficSign_SupplementarySign::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.TrafficSign.SupplementarySign)
  // optional .osi3.BaseStationary base = 1;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->base_, false, target);
  }

  // optional .osi3.TrafficSign.SupplementarySign.Classification classification = 2;
  if (has_classification()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->classification_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.TrafficSign.SupplementarySign)
  return target;
}

int TrafficSign_SupplementarySign::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.TrafficSign.SupplementarySign)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .osi3.BaseStationary base = 1;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->base_);
    }

    // optional .osi3.TrafficSign.SupplementarySign.Classification classification = 2;
    if (has_classification()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->classification_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrafficSign_SupplementarySign::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.TrafficSign.SupplementarySign)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TrafficSign_SupplementarySign* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficSign_SupplementarySign>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.TrafficSign.SupplementarySign)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.TrafficSign.SupplementarySign)
    MergeFrom(*source);
  }
}

void TrafficSign_SupplementarySign::MergeFrom(const TrafficSign_SupplementarySign& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.TrafficSign.SupplementarySign)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_base()) {
      mutable_base()->::osi3::BaseStationary::MergeFrom(from.base());
    }
    if (from.has_classification()) {
      mutable_classification()->::osi3::TrafficSign_SupplementarySign_Classification::MergeFrom(from.classification());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TrafficSign_SupplementarySign::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.TrafficSign.SupplementarySign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficSign_SupplementarySign::CopyFrom(const TrafficSign_SupplementarySign& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.TrafficSign.SupplementarySign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficSign_SupplementarySign::IsInitialized() const {

  return true;
}

void TrafficSign_SupplementarySign::Swap(TrafficSign_SupplementarySign* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrafficSign_SupplementarySign::InternalSwap(TrafficSign_SupplementarySign* other) {
  std::swap(base_, other->base_);
  std::swap(classification_, other->classification_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TrafficSign_SupplementarySign::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrafficSign_SupplementarySign_descriptor_;
  metadata.reflection = TrafficSign_SupplementarySign_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficSign::kIdFieldNumber;
const int TrafficSign::kMainSignFieldNumber;
const int TrafficSign::kSupplementarySignFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficSign::TrafficSign()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.TrafficSign)
}

void TrafficSign::InitAsDefaultInstance() {
  id_ = const_cast< ::osi3::Identifier*>(&::osi3::Identifier::default_instance());
  main_sign_ = const_cast< ::osi3::TrafficSign_MainSign*>(&::osi3::TrafficSign_MainSign::default_instance());
}

TrafficSign::TrafficSign(const TrafficSign& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.TrafficSign)
}

void TrafficSign::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  main_sign_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrafficSign::~TrafficSign() {
  // @@protoc_insertion_point(destructor:osi3.TrafficSign)
  SharedDtor();
}

void TrafficSign::SharedDtor() {
  if (this != default_instance_) {
    delete id_;
    delete main_sign_;
  }
}

void TrafficSign::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrafficSign::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficSign_descriptor_;
}

const TrafficSign& TrafficSign::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5ftrafficsign_2eproto();
  return *default_instance_;
}

TrafficSign* TrafficSign::default_instance_ = NULL;

TrafficSign* TrafficSign::New(::google::protobuf::Arena* arena) const {
  TrafficSign* n = new TrafficSign;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrafficSign::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.TrafficSign)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_id()) {
      if (id_ != NULL) id_->::osi3::Identifier::Clear();
    }
    if (has_main_sign()) {
      if (main_sign_ != NULL) main_sign_->::osi3::TrafficSign_MainSign::Clear();
    }
  }
  supplementary_sign_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TrafficSign::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.TrafficSign)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.Identifier id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_main_sign;
        break;
      }

      // optional .osi3.TrafficSign.MainSign main_sign = 2;
      case 2: {
        if (tag == 18) {
         parse_main_sign:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_main_sign()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_supplementary_sign;
        break;
      }

      // repeated .osi3.TrafficSign.SupplementarySign supplementary_sign = 3;
      case 3: {
        if (tag == 26) {
         parse_supplementary_sign:
          DO_(input->IncrementRecursionDepth());
         parse_loop_supplementary_sign:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_supplementary_sign()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_supplementary_sign;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.TrafficSign)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.TrafficSign)
  return false;
#undef DO_
}

void TrafficSign::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.TrafficSign)
  // optional .osi3.Identifier id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->id_, output);
  }

  // optional .osi3.TrafficSign.MainSign main_sign = 2;
  if (has_main_sign()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->main_sign_, output);
  }

  // repeated .osi3.TrafficSign.SupplementarySign supplementary_sign = 3;
  for (unsigned int i = 0, n = this->supplementary_sign_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->supplementary_sign(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.TrafficSign)
}

::google::protobuf::uint8* TrafficSign::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.TrafficSign)
  // optional .osi3.Identifier id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->id_, false, target);
  }

  // optional .osi3.TrafficSign.MainSign main_sign = 2;
  if (has_main_sign()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->main_sign_, false, target);
  }

  // repeated .osi3.TrafficSign.SupplementarySign supplementary_sign = 3;
  for (unsigned int i = 0, n = this->supplementary_sign_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->supplementary_sign(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.TrafficSign)
  return target;
}

int TrafficSign::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.TrafficSign)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .osi3.Identifier id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->id_);
    }

    // optional .osi3.TrafficSign.MainSign main_sign = 2;
    if (has_main_sign()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->main_sign_);
    }

  }
  // repeated .osi3.TrafficSign.SupplementarySign supplementary_sign = 3;
  total_size += 1 * this->supplementary_sign_size();
  for (int i = 0; i < this->supplementary_sign_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->supplementary_sign(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrafficSign::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.TrafficSign)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TrafficSign* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficSign>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.TrafficSign)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.TrafficSign)
    MergeFrom(*source);
  }
}

void TrafficSign::MergeFrom(const TrafficSign& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.TrafficSign)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  supplementary_sign_.MergeFrom(from.supplementary_sign_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::osi3::Identifier::MergeFrom(from.id());
    }
    if (from.has_main_sign()) {
      mutable_main_sign()->::osi3::TrafficSign_MainSign::MergeFrom(from.main_sign());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TrafficSign::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.TrafficSign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficSign::CopyFrom(const TrafficSign& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.TrafficSign)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficSign::IsInitialized() const {

  return true;
}

void TrafficSign::Swap(TrafficSign* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrafficSign::InternalSwap(TrafficSign* other) {
  std::swap(id_, other->id_);
  std::swap(main_sign_, other->main_sign_);
  supplementary_sign_.UnsafeArenaSwap(&other->supplementary_sign_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TrafficSign::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrafficSign_descriptor_;
  metadata.reflection = TrafficSign_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TrafficSign_MainSign_Classification

// optional .osi3.TrafficSign.Variability variability = 1;
bool TrafficSign_MainSign_Classification::has_variability() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TrafficSign_MainSign_Classification::set_has_variability() {
  _has_bits_[0] |= 0x00000001u;
}
void TrafficSign_MainSign_Classification::clear_has_variability() {
  _has_bits_[0] &= ~0x00000001u;
}
void TrafficSign_MainSign_Classification::clear_variability() {
  variability_ = 0;
  clear_has_variability();
}
 ::osi3::TrafficSign_Variability TrafficSign_MainSign_Classification::variability() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.variability)
  return static_cast< ::osi3::TrafficSign_Variability >(variability_);
}
 void TrafficSign_MainSign_Classification::set_variability(::osi3::TrafficSign_Variability value) {
  assert(::osi3::TrafficSign_Variability_IsValid(value));
  set_has_variability();
  variability_ = value;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.variability)
}

// optional .osi3.TrafficSign.MainSign.Classification.Type type = 2;
bool TrafficSign_MainSign_Classification::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TrafficSign_MainSign_Classification::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
void TrafficSign_MainSign_Classification::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void TrafficSign_MainSign_Classification::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::osi3::TrafficSign_MainSign_Classification_Type TrafficSign_MainSign_Classification::type() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.type)
  return static_cast< ::osi3::TrafficSign_MainSign_Classification_Type >(type_);
}
 void TrafficSign_MainSign_Classification::set_type(::osi3::TrafficSign_MainSign_Classification_Type value) {
  assert(::osi3::TrafficSign_MainSign_Classification_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.type)
}

// optional .osi3.TrafficSignValue value = 3;
bool TrafficSign_MainSign_Classification::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TrafficSign_MainSign_Classification::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
void TrafficSign_MainSign_Classification::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
void TrafficSign_MainSign_Classification::clear_value() {
  if (value_ != NULL) value_->::osi3::TrafficSignValue::Clear();
  clear_has_value();
}
const ::osi3::TrafficSignValue& TrafficSign_MainSign_Classification::value() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
::osi3::TrafficSignValue* TrafficSign_MainSign_Classification::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::osi3::TrafficSignValue;
  }
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.value)
  return value_;
}
::osi3::TrafficSignValue* TrafficSign_MainSign_Classification::release_value() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.Classification.value)
  clear_has_value();
  ::osi3::TrafficSignValue* temp = value_;
  value_ = NULL;
  return temp;
}
void TrafficSign_MainSign_Classification::set_allocated_value(::osi3::TrafficSignValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.Classification.value)
}

// optional .osi3.TrafficSign.MainSign.Classification.DirectionScope direction_scope = 4;
bool TrafficSign_MainSign_Classification::has_direction_scope() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TrafficSign_MainSign_Classification::set_has_direction_scope() {
  _has_bits_[0] |= 0x00000008u;
}
void TrafficSign_MainSign_Classification::clear_has_direction_scope() {
  _has_bits_[0] &= ~0x00000008u;
}
void TrafficSign_MainSign_Classification::clear_direction_scope() {
  direction_scope_ = 0;
  clear_has_direction_scope();
}
 ::osi3::TrafficSign_MainSign_Classification_DirectionScope TrafficSign_MainSign_Classification::direction_scope() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.direction_scope)
  return static_cast< ::osi3::TrafficSign_MainSign_Classification_DirectionScope >(direction_scope_);
}
 void TrafficSign_MainSign_Classification::set_direction_scope(::osi3::TrafficSign_MainSign_Classification_DirectionScope value) {
  assert(::osi3::TrafficSign_MainSign_Classification_DirectionScope_IsValid(value));
  set_has_direction_scope();
  direction_scope_ = value;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.MainSign.Classification.direction_scope)
}

// repeated .osi3.Identifier assigned_lane_id = 5;
int TrafficSign_MainSign_Classification::assigned_lane_id_size() const {
  return assigned_lane_id_.size();
}
void TrafficSign_MainSign_Classification::clear_assigned_lane_id() {
  assigned_lane_id_.Clear();
}
const ::osi3::Identifier& TrafficSign_MainSign_Classification::assigned_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return assigned_lane_id_.Get(index);
}
::osi3::Identifier* TrafficSign_MainSign_Classification::mutable_assigned_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return assigned_lane_id_.Mutable(index);
}
::osi3::Identifier* TrafficSign_MainSign_Classification::add_assigned_lane_id() {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return assigned_lane_id_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::Identifier >*
TrafficSign_MainSign_Classification::mutable_assigned_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return &assigned_lane_id_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::Identifier >&
TrafficSign_MainSign_Classification::assigned_lane_id() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.MainSign.Classification.assigned_lane_id)
  return assigned_lane_id_;
}

// -------------------------------------------------------------------

// TrafficSign_MainSign

// optional .osi3.BaseStationary base = 1;
bool TrafficSign_MainSign::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TrafficSign_MainSign::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
void TrafficSign_MainSign::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
void TrafficSign_MainSign::clear_base() {
  if (base_ != NULL) base_->::osi3::BaseStationary::Clear();
  clear_has_base();
}
const ::osi3::BaseStationary& TrafficSign_MainSign::base() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
::osi3::BaseStationary* TrafficSign_MainSign::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::osi3::BaseStationary;
  }
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.base)
  return base_;
}
::osi3::BaseStationary* TrafficSign_MainSign::release_base() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.base)
  clear_has_base();
  ::osi3::BaseStationary* temp = base_;
  base_ = NULL;
  return temp;
}
void TrafficSign_MainSign::set_allocated_base(::osi3::BaseStationary* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.base)
}

// optional .osi3.TrafficSign.MainSign.Classification classification = 2;
bool TrafficSign_MainSign::has_classification() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TrafficSign_MainSign::set_has_classification() {
  _has_bits_[0] |= 0x00000002u;
}
void TrafficSign_MainSign::clear_has_classification() {
  _has_bits_[0] &= ~0x00000002u;
}
void TrafficSign_MainSign::clear_classification() {
  if (classification_ != NULL) classification_->::osi3::TrafficSign_MainSign_Classification::Clear();
  clear_has_classification();
}
const ::osi3::TrafficSign_MainSign_Classification& TrafficSign_MainSign::classification() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.MainSign.classification)
  return classification_ != NULL ? *classification_ : *default_instance_->classification_;
}
::osi3::TrafficSign_MainSign_Classification* TrafficSign_MainSign::mutable_classification() {
  set_has_classification();
  if (classification_ == NULL) {
    classification_ = new ::osi3::TrafficSign_MainSign_Classification;
  }
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.MainSign.classification)
  return classification_;
}
::osi3::TrafficSign_MainSign_Classification* TrafficSign_MainSign::release_classification() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.MainSign.classification)
  clear_has_classification();
  ::osi3::TrafficSign_MainSign_Classification* temp = classification_;
  classification_ = NULL;
  return temp;
}
void TrafficSign_MainSign::set_allocated_classification(::osi3::TrafficSign_MainSign_Classification* classification) {
  delete classification_;
  classification_ = classification;
  if (classification) {
    set_has_classification();
  } else {
    clear_has_classification();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.MainSign.classification)
}

// -------------------------------------------------------------------

// TrafficSign_SupplementarySign_Classification

// optional .osi3.TrafficSign.Variability variability = 1;
bool TrafficSign_SupplementarySign_Classification::has_variability() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TrafficSign_SupplementarySign_Classification::set_has_variability() {
  _has_bits_[0] |= 0x00000001u;
}
void TrafficSign_SupplementarySign_Classification::clear_has_variability() {
  _has_bits_[0] &= ~0x00000001u;
}
void TrafficSign_SupplementarySign_Classification::clear_variability() {
  variability_ = 0;
  clear_has_variability();
}
 ::osi3::TrafficSign_Variability TrafficSign_SupplementarySign_Classification::variability() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.variability)
  return static_cast< ::osi3::TrafficSign_Variability >(variability_);
}
 void TrafficSign_SupplementarySign_Classification::set_variability(::osi3::TrafficSign_Variability value) {
  assert(::osi3::TrafficSign_Variability_IsValid(value));
  set_has_variability();
  variability_ = value;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.variability)
}

// optional .osi3.TrafficSign.SupplementarySign.Classification.Type type = 2;
bool TrafficSign_SupplementarySign_Classification::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TrafficSign_SupplementarySign_Classification::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
void TrafficSign_SupplementarySign_Classification::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void TrafficSign_SupplementarySign_Classification::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::osi3::TrafficSign_SupplementarySign_Classification_Type TrafficSign_SupplementarySign_Classification::type() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.type)
  return static_cast< ::osi3::TrafficSign_SupplementarySign_Classification_Type >(type_);
}
 void TrafficSign_SupplementarySign_Classification::set_type(::osi3::TrafficSign_SupplementarySign_Classification_Type value) {
  assert(::osi3::TrafficSign_SupplementarySign_Classification_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:osi3.TrafficSign.SupplementarySign.Classification.type)
}

// repeated .osi3.TrafficSignValue value = 3;
int TrafficSign_SupplementarySign_Classification::value_size() const {
  return value_.size();
}
void TrafficSign_SupplementarySign_Classification::clear_value() {
  value_.Clear();
}
const ::osi3::TrafficSignValue& TrafficSign_SupplementarySign_Classification::value(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.value)
  return value_.Get(index);
}
::osi3::TrafficSignValue* TrafficSign_SupplementarySign_Classification::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.value)
  return value_.Mutable(index);
}
::osi3::TrafficSignValue* TrafficSign_SupplementarySign_Classification::add_value() {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.value)
  return value_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::TrafficSignValue >*
TrafficSign_SupplementarySign_Classification::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.value)
  return &value_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::TrafficSignValue >&
TrafficSign_SupplementarySign_Classification::value() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.value)
  return value_;
}

// repeated .osi3.Identifier assigned_lane_id = 4;
int TrafficSign_SupplementarySign_Classification::assigned_lane_id_size() const {
  return assigned_lane_id_.size();
}
void TrafficSign_SupplementarySign_Classification::clear_assigned_lane_id() {
  assigned_lane_id_.Clear();
}
const ::osi3::Identifier& TrafficSign_SupplementarySign_Classification::assigned_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return assigned_lane_id_.Get(index);
}
::osi3::Identifier* TrafficSign_SupplementarySign_Classification::mutable_assigned_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return assigned_lane_id_.Mutable(index);
}
::osi3::Identifier* TrafficSign_SupplementarySign_Classification::add_assigned_lane_id() {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return assigned_lane_id_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::Identifier >*
TrafficSign_SupplementarySign_Classification::mutable_assigned_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return &assigned_lane_id_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::Identifier >&
TrafficSign_SupplementarySign_Classification::assigned_lane_id() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.SupplementarySign.Classification.assigned_lane_id)
  return assigned_lane_id_;
}

// -------------------------------------------------------------------

// TrafficSign_SupplementarySign

// optional .osi3.BaseStationary base = 1;
bool TrafficSign_SupplementarySign::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TrafficSign_SupplementarySign::set_has_base() {
  _has_bits_[0] |= 0x00000001u;
}
void TrafficSign_SupplementarySign::clear_has_base() {
  _has_bits_[0] &= ~0x00000001u;
}
void TrafficSign_SupplementarySign::clear_base() {
  if (base_ != NULL) base_->::osi3::BaseStationary::Clear();
  clear_has_base();
}
const ::osi3::BaseStationary& TrafficSign_SupplementarySign::base() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
::osi3::BaseStationary* TrafficSign_SupplementarySign::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::osi3::BaseStationary;
  }
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.base)
  return base_;
}
::osi3::BaseStationary* TrafficSign_SupplementarySign::release_base() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.base)
  clear_has_base();
  ::osi3::BaseStationary* temp = base_;
  base_ = NULL;
  return temp;
}
void TrafficSign_SupplementarySign::set_allocated_base(::osi3::BaseStationary* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.base)
}

// optional .osi3.TrafficSign.SupplementarySign.Classification classification = 2;
bool TrafficSign_SupplementarySign::has_classification() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TrafficSign_SupplementarySign::set_has_classification() {
  _has_bits_[0] |= 0x00000002u;
}
void TrafficSign_SupplementarySign::clear_has_classification() {
  _has_bits_[0] &= ~0x00000002u;
}
void TrafficSign_SupplementarySign::clear_classification() {
  if (classification_ != NULL) classification_->::osi3::TrafficSign_SupplementarySign_Classification::Clear();
  clear_has_classification();
}
const ::osi3::TrafficSign_SupplementarySign_Classification& TrafficSign_SupplementarySign::classification() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.SupplementarySign.classification)
  return classification_ != NULL ? *classification_ : *default_instance_->classification_;
}
::osi3::TrafficSign_SupplementarySign_Classification* TrafficSign_SupplementarySign::mutable_classification() {
  set_has_classification();
  if (classification_ == NULL) {
    classification_ = new ::osi3::TrafficSign_SupplementarySign_Classification;
  }
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.SupplementarySign.classification)
  return classification_;
}
::osi3::TrafficSign_SupplementarySign_Classification* TrafficSign_SupplementarySign::release_classification() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.SupplementarySign.classification)
  clear_has_classification();
  ::osi3::TrafficSign_SupplementarySign_Classification* temp = classification_;
  classification_ = NULL;
  return temp;
}
void TrafficSign_SupplementarySign::set_allocated_classification(::osi3::TrafficSign_SupplementarySign_Classification* classification) {
  delete classification_;
  classification_ = classification;
  if (classification) {
    set_has_classification();
  } else {
    clear_has_classification();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.SupplementarySign.classification)
}

// -------------------------------------------------------------------

// TrafficSign

// optional .osi3.Identifier id = 1;
bool TrafficSign::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TrafficSign::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void TrafficSign::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void TrafficSign::clear_id() {
  if (id_ != NULL) id_->::osi3::Identifier::Clear();
  clear_has_id();
}
const ::osi3::Identifier& TrafficSign::id() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
::osi3::Identifier* TrafficSign::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.id)
  return id_;
}
::osi3::Identifier* TrafficSign::release_id() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.id)
  clear_has_id();
  ::osi3::Identifier* temp = id_;
  id_ = NULL;
  return temp;
}
void TrafficSign::set_allocated_id(::osi3::Identifier* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.id)
}

// optional .osi3.TrafficSign.MainSign main_sign = 2;
bool TrafficSign::has_main_sign() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TrafficSign::set_has_main_sign() {
  _has_bits_[0] |= 0x00000002u;
}
void TrafficSign::clear_has_main_sign() {
  _has_bits_[0] &= ~0x00000002u;
}
void TrafficSign::clear_main_sign() {
  if (main_sign_ != NULL) main_sign_->::osi3::TrafficSign_MainSign::Clear();
  clear_has_main_sign();
}
const ::osi3::TrafficSign_MainSign& TrafficSign::main_sign() const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.main_sign)
  return main_sign_ != NULL ? *main_sign_ : *default_instance_->main_sign_;
}
::osi3::TrafficSign_MainSign* TrafficSign::mutable_main_sign() {
  set_has_main_sign();
  if (main_sign_ == NULL) {
    main_sign_ = new ::osi3::TrafficSign_MainSign;
  }
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.main_sign)
  return main_sign_;
}
::osi3::TrafficSign_MainSign* TrafficSign::release_main_sign() {
  // @@protoc_insertion_point(field_release:osi3.TrafficSign.main_sign)
  clear_has_main_sign();
  ::osi3::TrafficSign_MainSign* temp = main_sign_;
  main_sign_ = NULL;
  return temp;
}
void TrafficSign::set_allocated_main_sign(::osi3::TrafficSign_MainSign* main_sign) {
  delete main_sign_;
  main_sign_ = main_sign;
  if (main_sign) {
    set_has_main_sign();
  } else {
    clear_has_main_sign();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.TrafficSign.main_sign)
}

// repeated .osi3.TrafficSign.SupplementarySign supplementary_sign = 3;
int TrafficSign::supplementary_sign_size() const {
  return supplementary_sign_.size();
}
void TrafficSign::clear_supplementary_sign() {
  supplementary_sign_.Clear();
}
const ::osi3::TrafficSign_SupplementarySign& TrafficSign::supplementary_sign(int index) const {
  // @@protoc_insertion_point(field_get:osi3.TrafficSign.supplementary_sign)
  return supplementary_sign_.Get(index);
}
::osi3::TrafficSign_SupplementarySign* TrafficSign::mutable_supplementary_sign(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.TrafficSign.supplementary_sign)
  return supplementary_sign_.Mutable(index);
}
::osi3::TrafficSign_SupplementarySign* TrafficSign::add_supplementary_sign() {
  // @@protoc_insertion_point(field_add:osi3.TrafficSign.supplementary_sign)
  return supplementary_sign_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign >*
TrafficSign::mutable_supplementary_sign() {
  // @@protoc_insertion_point(field_mutable_list:osi3.TrafficSign.supplementary_sign)
  return &supplementary_sign_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::TrafficSign_SupplementarySign >&
TrafficSign::supplementary_sign() const {
  // @@protoc_insertion_point(field_list:osi3.TrafficSign.supplementary_sign)
  return supplementary_sign_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace osi3

// @@protoc_insertion_point(global_scope)
