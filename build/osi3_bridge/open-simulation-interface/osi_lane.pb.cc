// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: osi_lane.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "osi_lane.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace osi3 {

namespace {

const ::google::protobuf::Descriptor* Lane_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Lane_reflection_ = NULL;
const ::google::protobuf::Descriptor* Lane_Classification_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Lane_Classification_reflection_ = NULL;
const ::google::protobuf::Descriptor* Lane_Classification_RoadCondition_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Lane_Classification_RoadCondition_reflection_ = NULL;
const ::google::protobuf::Descriptor* Lane_Classification_LanePairing_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Lane_Classification_LanePairing_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Lane_Classification_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* LaneBoundary_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LaneBoundary_reflection_ = NULL;
const ::google::protobuf::Descriptor* LaneBoundary_BoundaryPoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LaneBoundary_BoundaryPoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* LaneBoundary_Classification_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LaneBoundary_Classification_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* LaneBoundary_Classification_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* LaneBoundary_Classification_Color_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_osi_5flane_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_osi_5flane_2eproto() {
  protobuf_AddDesc_osi_5flane_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "osi_lane.proto");
  GOOGLE_CHECK(file != NULL);
  Lane_descriptor_ = file->message_type(0);
  static const int Lane_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane, classification_),
  };
  Lane_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Lane_descriptor_,
      Lane::default_instance_,
      Lane_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane, _has_bits_[0]),
      -1,
      -1,
      sizeof(Lane),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane, _internal_metadata_),
      -1);
  Lane_Classification_descriptor_ = Lane_descriptor_->nested_type(0);
  static const int Lane_Classification_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, is_host_vehicle_lane_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, centerline_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, centerline_is_driving_direction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, left_adjacent_lane_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, right_adjacent_lane_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, lane_pairing_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, right_lane_boundary_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, left_lane_boundary_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, free_lane_boundary_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, road_condition_),
  };
  Lane_Classification_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Lane_Classification_descriptor_,
      Lane_Classification::default_instance_,
      Lane_Classification_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, _has_bits_[0]),
      -1,
      -1,
      sizeof(Lane_Classification),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification, _internal_metadata_),
      -1);
  Lane_Classification_RoadCondition_descriptor_ = Lane_Classification_descriptor_->nested_type(0);
  static const int Lane_Classification_RoadCondition_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification_RoadCondition, surface_temperature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification_RoadCondition, surface_water_film_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification_RoadCondition, surface_freezing_point_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification_RoadCondition, surface_ice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification_RoadCondition, surface_roughness_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification_RoadCondition, surface_texture_),
  };
  Lane_Classification_RoadCondition_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Lane_Classification_RoadCondition_descriptor_,
      Lane_Classification_RoadCondition::default_instance_,
      Lane_Classification_RoadCondition_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification_RoadCondition, _has_bits_[0]),
      -1,
      -1,
      sizeof(Lane_Classification_RoadCondition),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification_RoadCondition, _internal_metadata_),
      -1);
  Lane_Classification_LanePairing_descriptor_ = Lane_Classification_descriptor_->nested_type(1);
  static const int Lane_Classification_LanePairing_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification_LanePairing, antecessor_lane_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification_LanePairing, successor_lane_id_),
  };
  Lane_Classification_LanePairing_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Lane_Classification_LanePairing_descriptor_,
      Lane_Classification_LanePairing::default_instance_,
      Lane_Classification_LanePairing_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification_LanePairing, _has_bits_[0]),
      -1,
      -1,
      sizeof(Lane_Classification_LanePairing),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Lane_Classification_LanePairing, _internal_metadata_),
      -1);
  Lane_Classification_Type_descriptor_ = Lane_Classification_descriptor_->enum_type(0);
  LaneBoundary_descriptor_ = file->message_type(1);
  static const int LaneBoundary_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary, boundary_line_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary, classification_),
  };
  LaneBoundary_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LaneBoundary_descriptor_,
      LaneBoundary::default_instance_,
      LaneBoundary_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary, _has_bits_[0]),
      -1,
      -1,
      sizeof(LaneBoundary),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary, _internal_metadata_),
      -1);
  LaneBoundary_BoundaryPoint_descriptor_ = LaneBoundary_descriptor_->nested_type(0);
  static const int LaneBoundary_BoundaryPoint_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary_BoundaryPoint, position_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary_BoundaryPoint, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary_BoundaryPoint, height_),
  };
  LaneBoundary_BoundaryPoint_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LaneBoundary_BoundaryPoint_descriptor_,
      LaneBoundary_BoundaryPoint::default_instance_,
      LaneBoundary_BoundaryPoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _has_bits_[0]),
      -1,
      -1,
      sizeof(LaneBoundary_BoundaryPoint),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary_BoundaryPoint, _internal_metadata_),
      -1);
  LaneBoundary_Classification_descriptor_ = LaneBoundary_descriptor_->nested_type(1);
  static const int LaneBoundary_Classification_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary_Classification, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary_Classification, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary_Classification, limiting_structure_id_),
  };
  LaneBoundary_Classification_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LaneBoundary_Classification_descriptor_,
      LaneBoundary_Classification::default_instance_,
      LaneBoundary_Classification_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary_Classification, _has_bits_[0]),
      -1,
      -1,
      sizeof(LaneBoundary_Classification),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LaneBoundary_Classification, _internal_metadata_),
      -1);
  LaneBoundary_Classification_Type_descriptor_ = LaneBoundary_Classification_descriptor_->enum_type(0);
  LaneBoundary_Classification_Color_descriptor_ = LaneBoundary_Classification_descriptor_->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_osi_5flane_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Lane_descriptor_, &Lane::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Lane_Classification_descriptor_, &Lane_Classification::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Lane_Classification_RoadCondition_descriptor_, &Lane_Classification_RoadCondition::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Lane_Classification_LanePairing_descriptor_, &Lane_Classification_LanePairing::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LaneBoundary_descriptor_, &LaneBoundary::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LaneBoundary_BoundaryPoint_descriptor_, &LaneBoundary_BoundaryPoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LaneBoundary_Classification_descriptor_, &LaneBoundary_Classification::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_osi_5flane_2eproto() {
  delete Lane::default_instance_;
  delete Lane_reflection_;
  delete Lane_Classification::default_instance_;
  delete Lane_Classification_reflection_;
  delete Lane_Classification_RoadCondition::default_instance_;
  delete Lane_Classification_RoadCondition_reflection_;
  delete Lane_Classification_LanePairing::default_instance_;
  delete Lane_Classification_LanePairing_reflection_;
  delete LaneBoundary::default_instance_;
  delete LaneBoundary_reflection_;
  delete LaneBoundary_BoundaryPoint::default_instance_;
  delete LaneBoundary_BoundaryPoint_reflection_;
  delete LaneBoundary_Classification::default_instance_;
  delete LaneBoundary_Classification_reflection_;
}

void protobuf_AddDesc_osi_5flane_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_osi_5flane_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::osi3::protobuf_AddDesc_osi_5fcommon_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016osi_lane.proto\022\004osi3\032\020osi_common.proto"
    "\"\376\007\n\004Lane\022\034\n\002id\030\001 \001(\0132\020.osi3.Identifier\022"
    "1\n\016classification\030\002 \001(\0132\031.osi3.Lane.Clas"
    "sification\032\244\007\n\016Classification\022,\n\004type\030\001 "
    "\001(\0162\036.osi3.Lane.Classification.Type\022\034\n\024i"
    "s_host_vehicle_lane\030\002 \001(\010\022\"\n\ncenterline\030"
    "\003 \003(\0132\016.osi3.Vector3d\022\'\n\037centerline_is_d"
    "riving_direction\030\004 \001(\010\022/\n\025left_adjacent_"
    "lane_id\030\005 \003(\0132\020.osi3.Identifier\0220\n\026right"
    "_adjacent_lane_id\030\006 \003(\0132\020.osi3.Identifie"
    "r\022;\n\014lane_pairing\030\007 \003(\0132%.osi3.Lane.Clas"
    "sification.LanePairing\0220\n\026right_lane_bou"
    "ndary_id\030\010 \003(\0132\020.osi3.Identifier\022/\n\025left"
    "_lane_boundary_id\030\t \003(\0132\020.osi3.Identifie"
    "r\022/\n\025free_lane_boundary_id\030\n \003(\0132\020.osi3."
    "Identifier\022\?\n\016road_condition\030\013 \001(\0132\'.osi"
    "3.Lane.Classification.RoadCondition\032\261\001\n\r"
    "RoadCondition\022\033\n\023surface_temperature\030\001 \001"
    "(\001\022\032\n\022surface_water_film\030\002 \001(\001\022\036\n\026surfac"
    "e_freezing_point\030\003 \001(\001\022\023\n\013surface_ice\030\004 "
    "\001(\001\022\031\n\021surface_roughness\030\005 \001(\001\022\027\n\017surfac"
    "e_texture\030\006 \001(\001\032h\n\013LanePairing\022,\n\022antece"
    "ssor_lane_id\030\001 \001(\0132\020.osi3.Identifier\022+\n\021"
    "successor_lane_id\030\002 \001(\0132\020.osi3.Identifie"
    "r\"f\n\004Type\022\020\n\014TYPE_UNKNOWN\020\000\022\016\n\nTYPE_OTHE"
    "R\020\001\022\020\n\014TYPE_DRIVING\020\002\022\023\n\017TYPE_NONDRIVING"
    "\020\003\022\025\n\021TYPE_INTERSECTION\020\004\"\343\006\n\014LaneBounda"
    "ry\022\034\n\002id\030\001 \001(\0132\020.osi3.Identifier\0227\n\rboun"
    "dary_line\030\002 \003(\0132 .osi3.LaneBoundary.Boun"
    "daryPoint\0229\n\016classification\030\003 \001(\0132!.osi3"
    ".LaneBoundary.Classification\032P\n\rBoundary"
    "Point\022 \n\010position\030\001 \001(\0132\016.osi3.Vector3d\022"
    "\r\n\005width\030\002 \001(\001\022\016\n\006height\030\003 \001(\001\032\356\004\n\016Class"
    "ification\0224\n\004type\030\001 \001(\0162&.osi3.LaneBound"
    "ary.Classification.Type\0226\n\005color\030\002 \001(\0162\'"
    ".osi3.LaneBoundary.Classification.Color\022"
    "/\n\025limiting_structure_id\030\003 \003(\0132\020.osi3.Id"
    "entifier\"\231\002\n\004Type\022\020\n\014TYPE_UNKNOWN\020\000\022\016\n\nT"
    "YPE_OTHER\020\001\022\020\n\014TYPE_NO_LINE\020\002\022\023\n\017TYPE_SO"
    "LID_LINE\020\003\022\024\n\020TYPE_DASHED_LINE\020\004\022\023\n\017TYPE"
    "_BOTTS_DOTS\020\005\022\022\n\016TYPE_ROAD_EDGE\020\006\022\022\n\016TYP"
    "E_SNOW_EDGE\020\007\022\023\n\017TYPE_GRASS_EDGE\020\010\022\024\n\020TY"
    "PE_GRAVEL_EDGE\020\t\022\022\n\016TYPE_SOIL_EDGE\020\n\022\023\n\017"
    "TYPE_GUARD_RAIL\020\013\022\r\n\tTYPE_CURB\020\014\022\022\n\016TYPE"
    "_STRUCTURE\020\r\"\240\001\n\005Color\022\021\n\rCOLOR_UNKNOWN\020"
    "\000\022\017\n\013COLOR_OTHER\020\001\022\016\n\nCOLOR_NONE\020\002\022\017\n\013CO"
    "LOR_WHITE\020\003\022\020\n\014COLOR_YELLOW\020\004\022\r\n\tCOLOR_R"
    "ED\020\005\022\016\n\nCOLOR_BLUE\020\006\022\017\n\013COLOR_GREEN\020\007\022\020\n"
    "\014COLOR_VIOLET\020\010B\002H\001", 1939);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "osi_lane.proto", &protobuf_RegisterTypes);
  Lane::default_instance_ = new Lane();
  Lane_Classification::default_instance_ = new Lane_Classification();
  Lane_Classification_RoadCondition::default_instance_ = new Lane_Classification_RoadCondition();
  Lane_Classification_LanePairing::default_instance_ = new Lane_Classification_LanePairing();
  LaneBoundary::default_instance_ = new LaneBoundary();
  LaneBoundary_BoundaryPoint::default_instance_ = new LaneBoundary_BoundaryPoint();
  LaneBoundary_Classification::default_instance_ = new LaneBoundary_Classification();
  Lane::default_instance_->InitAsDefaultInstance();
  Lane_Classification::default_instance_->InitAsDefaultInstance();
  Lane_Classification_RoadCondition::default_instance_->InitAsDefaultInstance();
  Lane_Classification_LanePairing::default_instance_->InitAsDefaultInstance();
  LaneBoundary::default_instance_->InitAsDefaultInstance();
  LaneBoundary_BoundaryPoint::default_instance_->InitAsDefaultInstance();
  LaneBoundary_Classification::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_osi_5flane_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_osi_5flane_2eproto {
  StaticDescriptorInitializer_osi_5flane_2eproto() {
    protobuf_AddDesc_osi_5flane_2eproto();
  }
} static_descriptor_initializer_osi_5flane_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* Lane_Classification_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Lane_Classification_Type_descriptor_;
}
bool Lane_Classification_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Lane_Classification_Type Lane_Classification::TYPE_UNKNOWN;
const Lane_Classification_Type Lane_Classification::TYPE_OTHER;
const Lane_Classification_Type Lane_Classification::TYPE_DRIVING;
const Lane_Classification_Type Lane_Classification::TYPE_NONDRIVING;
const Lane_Classification_Type Lane_Classification::TYPE_INTERSECTION;
const Lane_Classification_Type Lane_Classification::Type_MIN;
const Lane_Classification_Type Lane_Classification::Type_MAX;
const int Lane_Classification::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Lane_Classification_RoadCondition::kSurfaceTemperatureFieldNumber;
const int Lane_Classification_RoadCondition::kSurfaceWaterFilmFieldNumber;
const int Lane_Classification_RoadCondition::kSurfaceFreezingPointFieldNumber;
const int Lane_Classification_RoadCondition::kSurfaceIceFieldNumber;
const int Lane_Classification_RoadCondition::kSurfaceRoughnessFieldNumber;
const int Lane_Classification_RoadCondition::kSurfaceTextureFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Lane_Classification_RoadCondition::Lane_Classification_RoadCondition()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.Lane.Classification.RoadCondition)
}

void Lane_Classification_RoadCondition::InitAsDefaultInstance() {
}

Lane_Classification_RoadCondition::Lane_Classification_RoadCondition(const Lane_Classification_RoadCondition& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.Lane.Classification.RoadCondition)
}

void Lane_Classification_RoadCondition::SharedCtor() {
  _cached_size_ = 0;
  surface_temperature_ = 0;
  surface_water_film_ = 0;
  surface_freezing_point_ = 0;
  surface_ice_ = 0;
  surface_roughness_ = 0;
  surface_texture_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Lane_Classification_RoadCondition::~Lane_Classification_RoadCondition() {
  // @@protoc_insertion_point(destructor:osi3.Lane.Classification.RoadCondition)
  SharedDtor();
}

void Lane_Classification_RoadCondition::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Lane_Classification_RoadCondition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Lane_Classification_RoadCondition::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Lane_Classification_RoadCondition_descriptor_;
}

const Lane_Classification_RoadCondition& Lane_Classification_RoadCondition::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5flane_2eproto();
  return *default_instance_;
}

Lane_Classification_RoadCondition* Lane_Classification_RoadCondition::default_instance_ = NULL;

Lane_Classification_RoadCondition* Lane_Classification_RoadCondition::New(::google::protobuf::Arena* arena) const {
  Lane_Classification_RoadCondition* n = new Lane_Classification_RoadCondition;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Lane_Classification_RoadCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Lane.Classification.RoadCondition)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Lane_Classification_RoadCondition, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Lane_Classification_RoadCondition*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(surface_temperature_, surface_texture_);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Lane_Classification_RoadCondition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.Lane.Classification.RoadCondition)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double surface_temperature = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &surface_temperature_)));
          set_has_surface_temperature();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_surface_water_film;
        break;
      }

      // optional double surface_water_film = 2;
      case 2: {
        if (tag == 17) {
         parse_surface_water_film:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &surface_water_film_)));
          set_has_surface_water_film();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_surface_freezing_point;
        break;
      }

      // optional double surface_freezing_point = 3;
      case 3: {
        if (tag == 25) {
         parse_surface_freezing_point:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &surface_freezing_point_)));
          set_has_surface_freezing_point();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_surface_ice;
        break;
      }

      // optional double surface_ice = 4;
      case 4: {
        if (tag == 33) {
         parse_surface_ice:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &surface_ice_)));
          set_has_surface_ice();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_surface_roughness;
        break;
      }

      // optional double surface_roughness = 5;
      case 5: {
        if (tag == 41) {
         parse_surface_roughness:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &surface_roughness_)));
          set_has_surface_roughness();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_surface_texture;
        break;
      }

      // optional double surface_texture = 6;
      case 6: {
        if (tag == 49) {
         parse_surface_texture:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &surface_texture_)));
          set_has_surface_texture();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.Lane.Classification.RoadCondition)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.Lane.Classification.RoadCondition)
  return false;
#undef DO_
}

void Lane_Classification_RoadCondition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.Lane.Classification.RoadCondition)
  // optional double surface_temperature = 1;
  if (has_surface_temperature()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->surface_temperature(), output);
  }

  // optional double surface_water_film = 2;
  if (has_surface_water_film()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->surface_water_film(), output);
  }

  // optional double surface_freezing_point = 3;
  if (has_surface_freezing_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->surface_freezing_point(), output);
  }

  // optional double surface_ice = 4;
  if (has_surface_ice()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->surface_ice(), output);
  }

  // optional double surface_roughness = 5;
  if (has_surface_roughness()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->surface_roughness(), output);
  }

  // optional double surface_texture = 6;
  if (has_surface_texture()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->surface_texture(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.Lane.Classification.RoadCondition)
}

::google::protobuf::uint8* Lane_Classification_RoadCondition::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.Lane.Classification.RoadCondition)
  // optional double surface_temperature = 1;
  if (has_surface_temperature()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->surface_temperature(), target);
  }

  // optional double surface_water_film = 2;
  if (has_surface_water_film()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->surface_water_film(), target);
  }

  // optional double surface_freezing_point = 3;
  if (has_surface_freezing_point()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->surface_freezing_point(), target);
  }

  // optional double surface_ice = 4;
  if (has_surface_ice()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->surface_ice(), target);
  }

  // optional double surface_roughness = 5;
  if (has_surface_roughness()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->surface_roughness(), target);
  }

  // optional double surface_texture = 6;
  if (has_surface_texture()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->surface_texture(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.Lane.Classification.RoadCondition)
  return target;
}

int Lane_Classification_RoadCondition::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.Lane.Classification.RoadCondition)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 63u) {
    // optional double surface_temperature = 1;
    if (has_surface_temperature()) {
      total_size += 1 + 8;
    }

    // optional double surface_water_film = 2;
    if (has_surface_water_film()) {
      total_size += 1 + 8;
    }

    // optional double surface_freezing_point = 3;
    if (has_surface_freezing_point()) {
      total_size += 1 + 8;
    }

    // optional double surface_ice = 4;
    if (has_surface_ice()) {
      total_size += 1 + 8;
    }

    // optional double surface_roughness = 5;
    if (has_surface_roughness()) {
      total_size += 1 + 8;
    }

    // optional double surface_texture = 6;
    if (has_surface_texture()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Lane_Classification_RoadCondition::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.Lane.Classification.RoadCondition)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Lane_Classification_RoadCondition* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Lane_Classification_RoadCondition>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.Lane.Classification.RoadCondition)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.Lane.Classification.RoadCondition)
    MergeFrom(*source);
  }
}

void Lane_Classification_RoadCondition::MergeFrom(const Lane_Classification_RoadCondition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.Lane.Classification.RoadCondition)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_surface_temperature()) {
      set_surface_temperature(from.surface_temperature());
    }
    if (from.has_surface_water_film()) {
      set_surface_water_film(from.surface_water_film());
    }
    if (from.has_surface_freezing_point()) {
      set_surface_freezing_point(from.surface_freezing_point());
    }
    if (from.has_surface_ice()) {
      set_surface_ice(from.surface_ice());
    }
    if (from.has_surface_roughness()) {
      set_surface_roughness(from.surface_roughness());
    }
    if (from.has_surface_texture()) {
      set_surface_texture(from.surface_texture());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Lane_Classification_RoadCondition::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.Lane.Classification.RoadCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Lane_Classification_RoadCondition::CopyFrom(const Lane_Classification_RoadCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Lane.Classification.RoadCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lane_Classification_RoadCondition::IsInitialized() const {

  return true;
}

void Lane_Classification_RoadCondition::Swap(Lane_Classification_RoadCondition* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Lane_Classification_RoadCondition::InternalSwap(Lane_Classification_RoadCondition* other) {
  std::swap(surface_temperature_, other->surface_temperature_);
  std::swap(surface_water_film_, other->surface_water_film_);
  std::swap(surface_freezing_point_, other->surface_freezing_point_);
  std::swap(surface_ice_, other->surface_ice_);
  std::swap(surface_roughness_, other->surface_roughness_);
  std::swap(surface_texture_, other->surface_texture_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Lane_Classification_RoadCondition::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Lane_Classification_RoadCondition_descriptor_;
  metadata.reflection = Lane_Classification_RoadCondition_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Lane_Classification_LanePairing::kAntecessorLaneIdFieldNumber;
const int Lane_Classification_LanePairing::kSuccessorLaneIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Lane_Classification_LanePairing::Lane_Classification_LanePairing()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.Lane.Classification.LanePairing)
}

void Lane_Classification_LanePairing::InitAsDefaultInstance() {
  antecessor_lane_id_ = const_cast< ::osi3::Identifier*>(&::osi3::Identifier::default_instance());
  successor_lane_id_ = const_cast< ::osi3::Identifier*>(&::osi3::Identifier::default_instance());
}

Lane_Classification_LanePairing::Lane_Classification_LanePairing(const Lane_Classification_LanePairing& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.Lane.Classification.LanePairing)
}

void Lane_Classification_LanePairing::SharedCtor() {
  _cached_size_ = 0;
  antecessor_lane_id_ = NULL;
  successor_lane_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Lane_Classification_LanePairing::~Lane_Classification_LanePairing() {
  // @@protoc_insertion_point(destructor:osi3.Lane.Classification.LanePairing)
  SharedDtor();
}

void Lane_Classification_LanePairing::SharedDtor() {
  if (this != default_instance_) {
    delete antecessor_lane_id_;
    delete successor_lane_id_;
  }
}

void Lane_Classification_LanePairing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Lane_Classification_LanePairing::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Lane_Classification_LanePairing_descriptor_;
}

const Lane_Classification_LanePairing& Lane_Classification_LanePairing::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5flane_2eproto();
  return *default_instance_;
}

Lane_Classification_LanePairing* Lane_Classification_LanePairing::default_instance_ = NULL;

Lane_Classification_LanePairing* Lane_Classification_LanePairing::New(::google::protobuf::Arena* arena) const {
  Lane_Classification_LanePairing* n = new Lane_Classification_LanePairing;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Lane_Classification_LanePairing::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Lane.Classification.LanePairing)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_antecessor_lane_id()) {
      if (antecessor_lane_id_ != NULL) antecessor_lane_id_->::osi3::Identifier::Clear();
    }
    if (has_successor_lane_id()) {
      if (successor_lane_id_ != NULL) successor_lane_id_->::osi3::Identifier::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Lane_Classification_LanePairing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.Lane.Classification.LanePairing)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.Identifier antecessor_lane_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_antecessor_lane_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_successor_lane_id;
        break;
      }

      // optional .osi3.Identifier successor_lane_id = 2;
      case 2: {
        if (tag == 18) {
         parse_successor_lane_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_successor_lane_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.Lane.Classification.LanePairing)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.Lane.Classification.LanePairing)
  return false;
#undef DO_
}

void Lane_Classification_LanePairing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.Lane.Classification.LanePairing)
  // optional .osi3.Identifier antecessor_lane_id = 1;
  if (has_antecessor_lane_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->antecessor_lane_id_, output);
  }

  // optional .osi3.Identifier successor_lane_id = 2;
  if (has_successor_lane_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->successor_lane_id_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.Lane.Classification.LanePairing)
}

::google::protobuf::uint8* Lane_Classification_LanePairing::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.Lane.Classification.LanePairing)
  // optional .osi3.Identifier antecessor_lane_id = 1;
  if (has_antecessor_lane_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->antecessor_lane_id_, false, target);
  }

  // optional .osi3.Identifier successor_lane_id = 2;
  if (has_successor_lane_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->successor_lane_id_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.Lane.Classification.LanePairing)
  return target;
}

int Lane_Classification_LanePairing::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.Lane.Classification.LanePairing)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .osi3.Identifier antecessor_lane_id = 1;
    if (has_antecessor_lane_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->antecessor_lane_id_);
    }

    // optional .osi3.Identifier successor_lane_id = 2;
    if (has_successor_lane_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->successor_lane_id_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Lane_Classification_LanePairing::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.Lane.Classification.LanePairing)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Lane_Classification_LanePairing* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Lane_Classification_LanePairing>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.Lane.Classification.LanePairing)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.Lane.Classification.LanePairing)
    MergeFrom(*source);
  }
}

void Lane_Classification_LanePairing::MergeFrom(const Lane_Classification_LanePairing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.Lane.Classification.LanePairing)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_antecessor_lane_id()) {
      mutable_antecessor_lane_id()->::osi3::Identifier::MergeFrom(from.antecessor_lane_id());
    }
    if (from.has_successor_lane_id()) {
      mutable_successor_lane_id()->::osi3::Identifier::MergeFrom(from.successor_lane_id());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Lane_Classification_LanePairing::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.Lane.Classification.LanePairing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Lane_Classification_LanePairing::CopyFrom(const Lane_Classification_LanePairing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Lane.Classification.LanePairing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lane_Classification_LanePairing::IsInitialized() const {

  return true;
}

void Lane_Classification_LanePairing::Swap(Lane_Classification_LanePairing* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Lane_Classification_LanePairing::InternalSwap(Lane_Classification_LanePairing* other) {
  std::swap(antecessor_lane_id_, other->antecessor_lane_id_);
  std::swap(successor_lane_id_, other->successor_lane_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Lane_Classification_LanePairing::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Lane_Classification_LanePairing_descriptor_;
  metadata.reflection = Lane_Classification_LanePairing_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Lane_Classification::kTypeFieldNumber;
const int Lane_Classification::kIsHostVehicleLaneFieldNumber;
const int Lane_Classification::kCenterlineFieldNumber;
const int Lane_Classification::kCenterlineIsDrivingDirectionFieldNumber;
const int Lane_Classification::kLeftAdjacentLaneIdFieldNumber;
const int Lane_Classification::kRightAdjacentLaneIdFieldNumber;
const int Lane_Classification::kLanePairingFieldNumber;
const int Lane_Classification::kRightLaneBoundaryIdFieldNumber;
const int Lane_Classification::kLeftLaneBoundaryIdFieldNumber;
const int Lane_Classification::kFreeLaneBoundaryIdFieldNumber;
const int Lane_Classification::kRoadConditionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Lane_Classification::Lane_Classification()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.Lane.Classification)
}

void Lane_Classification::InitAsDefaultInstance() {
  road_condition_ = const_cast< ::osi3::Lane_Classification_RoadCondition*>(&::osi3::Lane_Classification_RoadCondition::default_instance());
}

Lane_Classification::Lane_Classification(const Lane_Classification& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.Lane.Classification)
}

void Lane_Classification::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  is_host_vehicle_lane_ = false;
  centerline_is_driving_direction_ = false;
  road_condition_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Lane_Classification::~Lane_Classification() {
  // @@protoc_insertion_point(destructor:osi3.Lane.Classification)
  SharedDtor();
}

void Lane_Classification::SharedDtor() {
  if (this != default_instance_) {
    delete road_condition_;
  }
}

void Lane_Classification::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Lane_Classification::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Lane_Classification_descriptor_;
}

const Lane_Classification& Lane_Classification::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5flane_2eproto();
  return *default_instance_;
}

Lane_Classification* Lane_Classification::default_instance_ = NULL;

Lane_Classification* Lane_Classification::New(::google::protobuf::Arena* arena) const {
  Lane_Classification* n = new Lane_Classification;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Lane_Classification::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Lane.Classification)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Lane_Classification, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Lane_Classification*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(type_, centerline_is_driving_direction_);
  if (has_road_condition()) {
    if (road_condition_ != NULL) road_condition_->::osi3::Lane_Classification_RoadCondition::Clear();
  }

#undef ZR_HELPER_
#undef ZR_

  centerline_.Clear();
  left_adjacent_lane_id_.Clear();
  right_adjacent_lane_id_.Clear();
  lane_pairing_.Clear();
  right_lane_boundary_id_.Clear();
  left_lane_boundary_id_.Clear();
  free_lane_boundary_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Lane_Classification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.Lane.Classification)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.Lane.Classification.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::osi3::Lane_Classification_Type_IsValid(value)) {
            set_type(static_cast< ::osi3::Lane_Classification_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_is_host_vehicle_lane;
        break;
      }

      // optional bool is_host_vehicle_lane = 2;
      case 2: {
        if (tag == 16) {
         parse_is_host_vehicle_lane:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_host_vehicle_lane_)));
          set_has_is_host_vehicle_lane();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_centerline;
        break;
      }

      // repeated .osi3.Vector3d centerline = 3;
      case 3: {
        if (tag == 26) {
         parse_centerline:
          DO_(input->IncrementRecursionDepth());
         parse_loop_centerline:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_centerline()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_centerline;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(32)) goto parse_centerline_is_driving_direction;
        break;
      }

      // optional bool centerline_is_driving_direction = 4;
      case 4: {
        if (tag == 32) {
         parse_centerline_is_driving_direction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &centerline_is_driving_direction_)));
          set_has_centerline_is_driving_direction();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_left_adjacent_lane_id;
        break;
      }

      // repeated .osi3.Identifier left_adjacent_lane_id = 5;
      case 5: {
        if (tag == 42) {
         parse_left_adjacent_lane_id:
          DO_(input->IncrementRecursionDepth());
         parse_loop_left_adjacent_lane_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_left_adjacent_lane_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_left_adjacent_lane_id;
        if (input->ExpectTag(50)) goto parse_loop_right_adjacent_lane_id;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .osi3.Identifier right_adjacent_lane_id = 6;
      case 6: {
        if (tag == 50) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_right_adjacent_lane_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_right_adjacent_lane_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_loop_right_adjacent_lane_id;
        if (input->ExpectTag(58)) goto parse_loop_lane_pairing;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .osi3.Lane.Classification.LanePairing lane_pairing = 7;
      case 7: {
        if (tag == 58) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_lane_pairing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_lane_pairing()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_loop_lane_pairing;
        if (input->ExpectTag(66)) goto parse_loop_right_lane_boundary_id;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .osi3.Identifier right_lane_boundary_id = 8;
      case 8: {
        if (tag == 66) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_right_lane_boundary_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_right_lane_boundary_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_loop_right_lane_boundary_id;
        if (input->ExpectTag(74)) goto parse_loop_left_lane_boundary_id;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .osi3.Identifier left_lane_boundary_id = 9;
      case 9: {
        if (tag == 74) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_left_lane_boundary_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_left_lane_boundary_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_loop_left_lane_boundary_id;
        if (input->ExpectTag(82)) goto parse_loop_free_lane_boundary_id;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .osi3.Identifier free_lane_boundary_id = 10;
      case 10: {
        if (tag == 82) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_free_lane_boundary_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_free_lane_boundary_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_loop_free_lane_boundary_id;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(90)) goto parse_road_condition;
        break;
      }

      // optional .osi3.Lane.Classification.RoadCondition road_condition = 11;
      case 11: {
        if (tag == 90) {
         parse_road_condition:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_road_condition()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.Lane.Classification)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.Lane.Classification)
  return false;
#undef DO_
}

void Lane_Classification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.Lane.Classification)
  // optional .osi3.Lane.Classification.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional bool is_host_vehicle_lane = 2;
  if (has_is_host_vehicle_lane()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_host_vehicle_lane(), output);
  }

  // repeated .osi3.Vector3d centerline = 3;
  for (unsigned int i = 0, n = this->centerline_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->centerline(i), output);
  }

  // optional bool centerline_is_driving_direction = 4;
  if (has_centerline_is_driving_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->centerline_is_driving_direction(), output);
  }

  // repeated .osi3.Identifier left_adjacent_lane_id = 5;
  for (unsigned int i = 0, n = this->left_adjacent_lane_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->left_adjacent_lane_id(i), output);
  }

  // repeated .osi3.Identifier right_adjacent_lane_id = 6;
  for (unsigned int i = 0, n = this->right_adjacent_lane_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->right_adjacent_lane_id(i), output);
  }

  // repeated .osi3.Lane.Classification.LanePairing lane_pairing = 7;
  for (unsigned int i = 0, n = this->lane_pairing_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->lane_pairing(i), output);
  }

  // repeated .osi3.Identifier right_lane_boundary_id = 8;
  for (unsigned int i = 0, n = this->right_lane_boundary_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->right_lane_boundary_id(i), output);
  }

  // repeated .osi3.Identifier left_lane_boundary_id = 9;
  for (unsigned int i = 0, n = this->left_lane_boundary_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->left_lane_boundary_id(i), output);
  }

  // repeated .osi3.Identifier free_lane_boundary_id = 10;
  for (unsigned int i = 0, n = this->free_lane_boundary_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->free_lane_boundary_id(i), output);
  }

  // optional .osi3.Lane.Classification.RoadCondition road_condition = 11;
  if (has_road_condition()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->road_condition_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.Lane.Classification)
}

::google::protobuf::uint8* Lane_Classification::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.Lane.Classification)
  // optional .osi3.Lane.Classification.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional bool is_host_vehicle_lane = 2;
  if (has_is_host_vehicle_lane()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->is_host_vehicle_lane(), target);
  }

  // repeated .osi3.Vector3d centerline = 3;
  for (unsigned int i = 0, n = this->centerline_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->centerline(i), false, target);
  }

  // optional bool centerline_is_driving_direction = 4;
  if (has_centerline_is_driving_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->centerline_is_driving_direction(), target);
  }

  // repeated .osi3.Identifier left_adjacent_lane_id = 5;
  for (unsigned int i = 0, n = this->left_adjacent_lane_id_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->left_adjacent_lane_id(i), false, target);
  }

  // repeated .osi3.Identifier right_adjacent_lane_id = 6;
  for (unsigned int i = 0, n = this->right_adjacent_lane_id_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, this->right_adjacent_lane_id(i), false, target);
  }

  // repeated .osi3.Lane.Classification.LanePairing lane_pairing = 7;
  for (unsigned int i = 0, n = this->lane_pairing_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, this->lane_pairing(i), false, target);
  }

  // repeated .osi3.Identifier right_lane_boundary_id = 8;
  for (unsigned int i = 0, n = this->right_lane_boundary_id_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, this->right_lane_boundary_id(i), false, target);
  }

  // repeated .osi3.Identifier left_lane_boundary_id = 9;
  for (unsigned int i = 0, n = this->left_lane_boundary_id_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, this->left_lane_boundary_id(i), false, target);
  }

  // repeated .osi3.Identifier free_lane_boundary_id = 10;
  for (unsigned int i = 0, n = this->free_lane_boundary_id_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, this->free_lane_boundary_id(i), false, target);
  }

  // optional .osi3.Lane.Classification.RoadCondition road_condition = 11;
  if (has_road_condition()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *this->road_condition_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.Lane.Classification)
  return target;
}

int Lane_Classification::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.Lane.Classification)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 11u) {
    // optional .osi3.Lane.Classification.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional bool is_host_vehicle_lane = 2;
    if (has_is_host_vehicle_lane()) {
      total_size += 1 + 1;
    }

    // optional bool centerline_is_driving_direction = 4;
    if (has_centerline_is_driving_direction()) {
      total_size += 1 + 1;
    }

  }
  // optional .osi3.Lane.Classification.RoadCondition road_condition = 11;
  if (has_road_condition()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->road_condition_);
  }

  // repeated .osi3.Vector3d centerline = 3;
  total_size += 1 * this->centerline_size();
  for (int i = 0; i < this->centerline_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->centerline(i));
  }

  // repeated .osi3.Identifier left_adjacent_lane_id = 5;
  total_size += 1 * this->left_adjacent_lane_id_size();
  for (int i = 0; i < this->left_adjacent_lane_id_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->left_adjacent_lane_id(i));
  }

  // repeated .osi3.Identifier right_adjacent_lane_id = 6;
  total_size += 1 * this->right_adjacent_lane_id_size();
  for (int i = 0; i < this->right_adjacent_lane_id_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->right_adjacent_lane_id(i));
  }

  // repeated .osi3.Lane.Classification.LanePairing lane_pairing = 7;
  total_size += 1 * this->lane_pairing_size();
  for (int i = 0; i < this->lane_pairing_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lane_pairing(i));
  }

  // repeated .osi3.Identifier right_lane_boundary_id = 8;
  total_size += 1 * this->right_lane_boundary_id_size();
  for (int i = 0; i < this->right_lane_boundary_id_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->right_lane_boundary_id(i));
  }

  // repeated .osi3.Identifier left_lane_boundary_id = 9;
  total_size += 1 * this->left_lane_boundary_id_size();
  for (int i = 0; i < this->left_lane_boundary_id_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->left_lane_boundary_id(i));
  }

  // repeated .osi3.Identifier free_lane_boundary_id = 10;
  total_size += 1 * this->free_lane_boundary_id_size();
  for (int i = 0; i < this->free_lane_boundary_id_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->free_lane_boundary_id(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Lane_Classification::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.Lane.Classification)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Lane_Classification* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Lane_Classification>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.Lane.Classification)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.Lane.Classification)
    MergeFrom(*source);
  }
}

void Lane_Classification::MergeFrom(const Lane_Classification& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.Lane.Classification)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  centerline_.MergeFrom(from.centerline_);
  left_adjacent_lane_id_.MergeFrom(from.left_adjacent_lane_id_);
  right_adjacent_lane_id_.MergeFrom(from.right_adjacent_lane_id_);
  lane_pairing_.MergeFrom(from.lane_pairing_);
  right_lane_boundary_id_.MergeFrom(from.right_lane_boundary_id_);
  left_lane_boundary_id_.MergeFrom(from.left_lane_boundary_id_);
  free_lane_boundary_id_.MergeFrom(from.free_lane_boundary_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_is_host_vehicle_lane()) {
      set_is_host_vehicle_lane(from.is_host_vehicle_lane());
    }
    if (from.has_centerline_is_driving_direction()) {
      set_centerline_is_driving_direction(from.centerline_is_driving_direction());
    }
  }
  if (from._has_bits_[10 / 32] & (0xffu << (10 % 32))) {
    if (from.has_road_condition()) {
      mutable_road_condition()->::osi3::Lane_Classification_RoadCondition::MergeFrom(from.road_condition());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Lane_Classification::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.Lane.Classification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Lane_Classification::CopyFrom(const Lane_Classification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Lane.Classification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lane_Classification::IsInitialized() const {

  return true;
}

void Lane_Classification::Swap(Lane_Classification* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Lane_Classification::InternalSwap(Lane_Classification* other) {
  std::swap(type_, other->type_);
  std::swap(is_host_vehicle_lane_, other->is_host_vehicle_lane_);
  centerline_.UnsafeArenaSwap(&other->centerline_);
  std::swap(centerline_is_driving_direction_, other->centerline_is_driving_direction_);
  left_adjacent_lane_id_.UnsafeArenaSwap(&other->left_adjacent_lane_id_);
  right_adjacent_lane_id_.UnsafeArenaSwap(&other->right_adjacent_lane_id_);
  lane_pairing_.UnsafeArenaSwap(&other->lane_pairing_);
  right_lane_boundary_id_.UnsafeArenaSwap(&other->right_lane_boundary_id_);
  left_lane_boundary_id_.UnsafeArenaSwap(&other->left_lane_boundary_id_);
  free_lane_boundary_id_.UnsafeArenaSwap(&other->free_lane_boundary_id_);
  std::swap(road_condition_, other->road_condition_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Lane_Classification::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Lane_Classification_descriptor_;
  metadata.reflection = Lane_Classification_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Lane::kIdFieldNumber;
const int Lane::kClassificationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Lane::Lane()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.Lane)
}

void Lane::InitAsDefaultInstance() {
  id_ = const_cast< ::osi3::Identifier*>(&::osi3::Identifier::default_instance());
  classification_ = const_cast< ::osi3::Lane_Classification*>(&::osi3::Lane_Classification::default_instance());
}

Lane::Lane(const Lane& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.Lane)
}

void Lane::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  classification_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Lane::~Lane() {
  // @@protoc_insertion_point(destructor:osi3.Lane)
  SharedDtor();
}

void Lane::SharedDtor() {
  if (this != default_instance_) {
    delete id_;
    delete classification_;
  }
}

void Lane::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Lane::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Lane_descriptor_;
}

const Lane& Lane::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5flane_2eproto();
  return *default_instance_;
}

Lane* Lane::default_instance_ = NULL;

Lane* Lane::New(::google::protobuf::Arena* arena) const {
  Lane* n = new Lane;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Lane::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.Lane)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_id()) {
      if (id_ != NULL) id_->::osi3::Identifier::Clear();
    }
    if (has_classification()) {
      if (classification_ != NULL) classification_->::osi3::Lane_Classification::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Lane::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.Lane)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.Identifier id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_classification;
        break;
      }

      // optional .osi3.Lane.Classification classification = 2;
      case 2: {
        if (tag == 18) {
         parse_classification:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_classification()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.Lane)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.Lane)
  return false;
#undef DO_
}

void Lane::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.Lane)
  // optional .osi3.Identifier id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->id_, output);
  }

  // optional .osi3.Lane.Classification classification = 2;
  if (has_classification()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->classification_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.Lane)
}

::google::protobuf::uint8* Lane::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.Lane)
  // optional .osi3.Identifier id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->id_, false, target);
  }

  // optional .osi3.Lane.Classification classification = 2;
  if (has_classification()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->classification_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.Lane)
  return target;
}

int Lane::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.Lane)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .osi3.Identifier id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->id_);
    }

    // optional .osi3.Lane.Classification classification = 2;
    if (has_classification()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->classification_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Lane::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.Lane)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Lane* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Lane>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.Lane)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.Lane)
    MergeFrom(*source);
  }
}

void Lane::MergeFrom(const Lane& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.Lane)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::osi3::Identifier::MergeFrom(from.id());
    }
    if (from.has_classification()) {
      mutable_classification()->::osi3::Lane_Classification::MergeFrom(from.classification());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Lane::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.Lane)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Lane::CopyFrom(const Lane& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.Lane)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Lane::IsInitialized() const {

  return true;
}

void Lane::Swap(Lane* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Lane::InternalSwap(Lane* other) {
  std::swap(id_, other->id_);
  std::swap(classification_, other->classification_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Lane::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Lane_descriptor_;
  metadata.reflection = Lane_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Lane_Classification_RoadCondition

// optional double surface_temperature = 1;
bool Lane_Classification_RoadCondition::has_surface_temperature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Lane_Classification_RoadCondition::set_has_surface_temperature() {
  _has_bits_[0] |= 0x00000001u;
}
void Lane_Classification_RoadCondition::clear_has_surface_temperature() {
  _has_bits_[0] &= ~0x00000001u;
}
void Lane_Classification_RoadCondition::clear_surface_temperature() {
  surface_temperature_ = 0;
  clear_has_surface_temperature();
}
 double Lane_Classification_RoadCondition::surface_temperature() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.RoadCondition.surface_temperature)
  return surface_temperature_;
}
 void Lane_Classification_RoadCondition::set_surface_temperature(double value) {
  set_has_surface_temperature();
  surface_temperature_ = value;
  // @@protoc_insertion_point(field_set:osi3.Lane.Classification.RoadCondition.surface_temperature)
}

// optional double surface_water_film = 2;
bool Lane_Classification_RoadCondition::has_surface_water_film() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Lane_Classification_RoadCondition::set_has_surface_water_film() {
  _has_bits_[0] |= 0x00000002u;
}
void Lane_Classification_RoadCondition::clear_has_surface_water_film() {
  _has_bits_[0] &= ~0x00000002u;
}
void Lane_Classification_RoadCondition::clear_surface_water_film() {
  surface_water_film_ = 0;
  clear_has_surface_water_film();
}
 double Lane_Classification_RoadCondition::surface_water_film() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.RoadCondition.surface_water_film)
  return surface_water_film_;
}
 void Lane_Classification_RoadCondition::set_surface_water_film(double value) {
  set_has_surface_water_film();
  surface_water_film_ = value;
  // @@protoc_insertion_point(field_set:osi3.Lane.Classification.RoadCondition.surface_water_film)
}

// optional double surface_freezing_point = 3;
bool Lane_Classification_RoadCondition::has_surface_freezing_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Lane_Classification_RoadCondition::set_has_surface_freezing_point() {
  _has_bits_[0] |= 0x00000004u;
}
void Lane_Classification_RoadCondition::clear_has_surface_freezing_point() {
  _has_bits_[0] &= ~0x00000004u;
}
void Lane_Classification_RoadCondition::clear_surface_freezing_point() {
  surface_freezing_point_ = 0;
  clear_has_surface_freezing_point();
}
 double Lane_Classification_RoadCondition::surface_freezing_point() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.RoadCondition.surface_freezing_point)
  return surface_freezing_point_;
}
 void Lane_Classification_RoadCondition::set_surface_freezing_point(double value) {
  set_has_surface_freezing_point();
  surface_freezing_point_ = value;
  // @@protoc_insertion_point(field_set:osi3.Lane.Classification.RoadCondition.surface_freezing_point)
}

// optional double surface_ice = 4;
bool Lane_Classification_RoadCondition::has_surface_ice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Lane_Classification_RoadCondition::set_has_surface_ice() {
  _has_bits_[0] |= 0x00000008u;
}
void Lane_Classification_RoadCondition::clear_has_surface_ice() {
  _has_bits_[0] &= ~0x00000008u;
}
void Lane_Classification_RoadCondition::clear_surface_ice() {
  surface_ice_ = 0;
  clear_has_surface_ice();
}
 double Lane_Classification_RoadCondition::surface_ice() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.RoadCondition.surface_ice)
  return surface_ice_;
}
 void Lane_Classification_RoadCondition::set_surface_ice(double value) {
  set_has_surface_ice();
  surface_ice_ = value;
  // @@protoc_insertion_point(field_set:osi3.Lane.Classification.RoadCondition.surface_ice)
}

// optional double surface_roughness = 5;
bool Lane_Classification_RoadCondition::has_surface_roughness() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Lane_Classification_RoadCondition::set_has_surface_roughness() {
  _has_bits_[0] |= 0x00000010u;
}
void Lane_Classification_RoadCondition::clear_has_surface_roughness() {
  _has_bits_[0] &= ~0x00000010u;
}
void Lane_Classification_RoadCondition::clear_surface_roughness() {
  surface_roughness_ = 0;
  clear_has_surface_roughness();
}
 double Lane_Classification_RoadCondition::surface_roughness() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.RoadCondition.surface_roughness)
  return surface_roughness_;
}
 void Lane_Classification_RoadCondition::set_surface_roughness(double value) {
  set_has_surface_roughness();
  surface_roughness_ = value;
  // @@protoc_insertion_point(field_set:osi3.Lane.Classification.RoadCondition.surface_roughness)
}

// optional double surface_texture = 6;
bool Lane_Classification_RoadCondition::has_surface_texture() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Lane_Classification_RoadCondition::set_has_surface_texture() {
  _has_bits_[0] |= 0x00000020u;
}
void Lane_Classification_RoadCondition::clear_has_surface_texture() {
  _has_bits_[0] &= ~0x00000020u;
}
void Lane_Classification_RoadCondition::clear_surface_texture() {
  surface_texture_ = 0;
  clear_has_surface_texture();
}
 double Lane_Classification_RoadCondition::surface_texture() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.RoadCondition.surface_texture)
  return surface_texture_;
}
 void Lane_Classification_RoadCondition::set_surface_texture(double value) {
  set_has_surface_texture();
  surface_texture_ = value;
  // @@protoc_insertion_point(field_set:osi3.Lane.Classification.RoadCondition.surface_texture)
}

// -------------------------------------------------------------------

// Lane_Classification_LanePairing

// optional .osi3.Identifier antecessor_lane_id = 1;
bool Lane_Classification_LanePairing::has_antecessor_lane_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Lane_Classification_LanePairing::set_has_antecessor_lane_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Lane_Classification_LanePairing::clear_has_antecessor_lane_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Lane_Classification_LanePairing::clear_antecessor_lane_id() {
  if (antecessor_lane_id_ != NULL) antecessor_lane_id_->::osi3::Identifier::Clear();
  clear_has_antecessor_lane_id();
}
const ::osi3::Identifier& Lane_Classification_LanePairing::antecessor_lane_id() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.LanePairing.antecessor_lane_id)
  return antecessor_lane_id_ != NULL ? *antecessor_lane_id_ : *default_instance_->antecessor_lane_id_;
}
::osi3::Identifier* Lane_Classification_LanePairing::mutable_antecessor_lane_id() {
  set_has_antecessor_lane_id();
  if (antecessor_lane_id_ == NULL) {
    antecessor_lane_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.Lane.Classification.LanePairing.antecessor_lane_id)
  return antecessor_lane_id_;
}
::osi3::Identifier* Lane_Classification_LanePairing::release_antecessor_lane_id() {
  // @@protoc_insertion_point(field_release:osi3.Lane.Classification.LanePairing.antecessor_lane_id)
  clear_has_antecessor_lane_id();
  ::osi3::Identifier* temp = antecessor_lane_id_;
  antecessor_lane_id_ = NULL;
  return temp;
}
void Lane_Classification_LanePairing::set_allocated_antecessor_lane_id(::osi3::Identifier* antecessor_lane_id) {
  delete antecessor_lane_id_;
  antecessor_lane_id_ = antecessor_lane_id;
  if (antecessor_lane_id) {
    set_has_antecessor_lane_id();
  } else {
    clear_has_antecessor_lane_id();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.Lane.Classification.LanePairing.antecessor_lane_id)
}

// optional .osi3.Identifier successor_lane_id = 2;
bool Lane_Classification_LanePairing::has_successor_lane_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Lane_Classification_LanePairing::set_has_successor_lane_id() {
  _has_bits_[0] |= 0x00000002u;
}
void Lane_Classification_LanePairing::clear_has_successor_lane_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void Lane_Classification_LanePairing::clear_successor_lane_id() {
  if (successor_lane_id_ != NULL) successor_lane_id_->::osi3::Identifier::Clear();
  clear_has_successor_lane_id();
}
const ::osi3::Identifier& Lane_Classification_LanePairing::successor_lane_id() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.LanePairing.successor_lane_id)
  return successor_lane_id_ != NULL ? *successor_lane_id_ : *default_instance_->successor_lane_id_;
}
::osi3::Identifier* Lane_Classification_LanePairing::mutable_successor_lane_id() {
  set_has_successor_lane_id();
  if (successor_lane_id_ == NULL) {
    successor_lane_id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.Lane.Classification.LanePairing.successor_lane_id)
  return successor_lane_id_;
}
::osi3::Identifier* Lane_Classification_LanePairing::release_successor_lane_id() {
  // @@protoc_insertion_point(field_release:osi3.Lane.Classification.LanePairing.successor_lane_id)
  clear_has_successor_lane_id();
  ::osi3::Identifier* temp = successor_lane_id_;
  successor_lane_id_ = NULL;
  return temp;
}
void Lane_Classification_LanePairing::set_allocated_successor_lane_id(::osi3::Identifier* successor_lane_id) {
  delete successor_lane_id_;
  successor_lane_id_ = successor_lane_id;
  if (successor_lane_id) {
    set_has_successor_lane_id();
  } else {
    clear_has_successor_lane_id();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.Lane.Classification.LanePairing.successor_lane_id)
}

// -------------------------------------------------------------------

// Lane_Classification

// optional .osi3.Lane.Classification.Type type = 1;
bool Lane_Classification::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Lane_Classification::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void Lane_Classification::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void Lane_Classification::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::osi3::Lane_Classification_Type Lane_Classification::type() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.type)
  return static_cast< ::osi3::Lane_Classification_Type >(type_);
}
 void Lane_Classification::set_type(::osi3::Lane_Classification_Type value) {
  assert(::osi3::Lane_Classification_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:osi3.Lane.Classification.type)
}

// optional bool is_host_vehicle_lane = 2;
bool Lane_Classification::has_is_host_vehicle_lane() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Lane_Classification::set_has_is_host_vehicle_lane() {
  _has_bits_[0] |= 0x00000002u;
}
void Lane_Classification::clear_has_is_host_vehicle_lane() {
  _has_bits_[0] &= ~0x00000002u;
}
void Lane_Classification::clear_is_host_vehicle_lane() {
  is_host_vehicle_lane_ = false;
  clear_has_is_host_vehicle_lane();
}
 bool Lane_Classification::is_host_vehicle_lane() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.is_host_vehicle_lane)
  return is_host_vehicle_lane_;
}
 void Lane_Classification::set_is_host_vehicle_lane(bool value) {
  set_has_is_host_vehicle_lane();
  is_host_vehicle_lane_ = value;
  // @@protoc_insertion_point(field_set:osi3.Lane.Classification.is_host_vehicle_lane)
}

// repeated .osi3.Vector3d centerline = 3;
int Lane_Classification::centerline_size() const {
  return centerline_.size();
}
void Lane_Classification::clear_centerline() {
  centerline_.Clear();
}
const ::osi3::Vector3d& Lane_Classification::centerline(int index) const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.centerline)
  return centerline_.Get(index);
}
::osi3::Vector3d* Lane_Classification::mutable_centerline(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.Lane.Classification.centerline)
  return centerline_.Mutable(index);
}
::osi3::Vector3d* Lane_Classification::add_centerline() {
  // @@protoc_insertion_point(field_add:osi3.Lane.Classification.centerline)
  return centerline_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::Vector3d >*
Lane_Classification::mutable_centerline() {
  // @@protoc_insertion_point(field_mutable_list:osi3.Lane.Classification.centerline)
  return &centerline_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::Vector3d >&
Lane_Classification::centerline() const {
  // @@protoc_insertion_point(field_list:osi3.Lane.Classification.centerline)
  return centerline_;
}

// optional bool centerline_is_driving_direction = 4;
bool Lane_Classification::has_centerline_is_driving_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Lane_Classification::set_has_centerline_is_driving_direction() {
  _has_bits_[0] |= 0x00000008u;
}
void Lane_Classification::clear_has_centerline_is_driving_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
void Lane_Classification::clear_centerline_is_driving_direction() {
  centerline_is_driving_direction_ = false;
  clear_has_centerline_is_driving_direction();
}
 bool Lane_Classification::centerline_is_driving_direction() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.centerline_is_driving_direction)
  return centerline_is_driving_direction_;
}
 void Lane_Classification::set_centerline_is_driving_direction(bool value) {
  set_has_centerline_is_driving_direction();
  centerline_is_driving_direction_ = value;
  // @@protoc_insertion_point(field_set:osi3.Lane.Classification.centerline_is_driving_direction)
}

// repeated .osi3.Identifier left_adjacent_lane_id = 5;
int Lane_Classification::left_adjacent_lane_id_size() const {
  return left_adjacent_lane_id_.size();
}
void Lane_Classification::clear_left_adjacent_lane_id() {
  left_adjacent_lane_id_.Clear();
}
const ::osi3::Identifier& Lane_Classification::left_adjacent_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.left_adjacent_lane_id)
  return left_adjacent_lane_id_.Get(index);
}
::osi3::Identifier* Lane_Classification::mutable_left_adjacent_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.Lane.Classification.left_adjacent_lane_id)
  return left_adjacent_lane_id_.Mutable(index);
}
::osi3::Identifier* Lane_Classification::add_left_adjacent_lane_id() {
  // @@protoc_insertion_point(field_add:osi3.Lane.Classification.left_adjacent_lane_id)
  return left_adjacent_lane_id_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::Identifier >*
Lane_Classification::mutable_left_adjacent_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:osi3.Lane.Classification.left_adjacent_lane_id)
  return &left_adjacent_lane_id_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::Identifier >&
Lane_Classification::left_adjacent_lane_id() const {
  // @@protoc_insertion_point(field_list:osi3.Lane.Classification.left_adjacent_lane_id)
  return left_adjacent_lane_id_;
}

// repeated .osi3.Identifier right_adjacent_lane_id = 6;
int Lane_Classification::right_adjacent_lane_id_size() const {
  return right_adjacent_lane_id_.size();
}
void Lane_Classification::clear_right_adjacent_lane_id() {
  right_adjacent_lane_id_.Clear();
}
const ::osi3::Identifier& Lane_Classification::right_adjacent_lane_id(int index) const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.right_adjacent_lane_id)
  return right_adjacent_lane_id_.Get(index);
}
::osi3::Identifier* Lane_Classification::mutable_right_adjacent_lane_id(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.Lane.Classification.right_adjacent_lane_id)
  return right_adjacent_lane_id_.Mutable(index);
}
::osi3::Identifier* Lane_Classification::add_right_adjacent_lane_id() {
  // @@protoc_insertion_point(field_add:osi3.Lane.Classification.right_adjacent_lane_id)
  return right_adjacent_lane_id_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::Identifier >*
Lane_Classification::mutable_right_adjacent_lane_id() {
  // @@protoc_insertion_point(field_mutable_list:osi3.Lane.Classification.right_adjacent_lane_id)
  return &right_adjacent_lane_id_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::Identifier >&
Lane_Classification::right_adjacent_lane_id() const {
  // @@protoc_insertion_point(field_list:osi3.Lane.Classification.right_adjacent_lane_id)
  return right_adjacent_lane_id_;
}

// repeated .osi3.Lane.Classification.LanePairing lane_pairing = 7;
int Lane_Classification::lane_pairing_size() const {
  return lane_pairing_.size();
}
void Lane_Classification::clear_lane_pairing() {
  lane_pairing_.Clear();
}
const ::osi3::Lane_Classification_LanePairing& Lane_Classification::lane_pairing(int index) const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.lane_pairing)
  return lane_pairing_.Get(index);
}
::osi3::Lane_Classification_LanePairing* Lane_Classification::mutable_lane_pairing(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.Lane.Classification.lane_pairing)
  return lane_pairing_.Mutable(index);
}
::osi3::Lane_Classification_LanePairing* Lane_Classification::add_lane_pairing() {
  // @@protoc_insertion_point(field_add:osi3.Lane.Classification.lane_pairing)
  return lane_pairing_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::Lane_Classification_LanePairing >*
Lane_Classification::mutable_lane_pairing() {
  // @@protoc_insertion_point(field_mutable_list:osi3.Lane.Classification.lane_pairing)
  return &lane_pairing_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::Lane_Classification_LanePairing >&
Lane_Classification::lane_pairing() const {
  // @@protoc_insertion_point(field_list:osi3.Lane.Classification.lane_pairing)
  return lane_pairing_;
}

// repeated .osi3.Identifier right_lane_boundary_id = 8;
int Lane_Classification::right_lane_boundary_id_size() const {
  return right_lane_boundary_id_.size();
}
void Lane_Classification::clear_right_lane_boundary_id() {
  right_lane_boundary_id_.Clear();
}
const ::osi3::Identifier& Lane_Classification::right_lane_boundary_id(int index) const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.right_lane_boundary_id)
  return right_lane_boundary_id_.Get(index);
}
::osi3::Identifier* Lane_Classification::mutable_right_lane_boundary_id(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.Lane.Classification.right_lane_boundary_id)
  return right_lane_boundary_id_.Mutable(index);
}
::osi3::Identifier* Lane_Classification::add_right_lane_boundary_id() {
  // @@protoc_insertion_point(field_add:osi3.Lane.Classification.right_lane_boundary_id)
  return right_lane_boundary_id_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::Identifier >*
Lane_Classification::mutable_right_lane_boundary_id() {
  // @@protoc_insertion_point(field_mutable_list:osi3.Lane.Classification.right_lane_boundary_id)
  return &right_lane_boundary_id_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::Identifier >&
Lane_Classification::right_lane_boundary_id() const {
  // @@protoc_insertion_point(field_list:osi3.Lane.Classification.right_lane_boundary_id)
  return right_lane_boundary_id_;
}

// repeated .osi3.Identifier left_lane_boundary_id = 9;
int Lane_Classification::left_lane_boundary_id_size() const {
  return left_lane_boundary_id_.size();
}
void Lane_Classification::clear_left_lane_boundary_id() {
  left_lane_boundary_id_.Clear();
}
const ::osi3::Identifier& Lane_Classification::left_lane_boundary_id(int index) const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.left_lane_boundary_id)
  return left_lane_boundary_id_.Get(index);
}
::osi3::Identifier* Lane_Classification::mutable_left_lane_boundary_id(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.Lane.Classification.left_lane_boundary_id)
  return left_lane_boundary_id_.Mutable(index);
}
::osi3::Identifier* Lane_Classification::add_left_lane_boundary_id() {
  // @@protoc_insertion_point(field_add:osi3.Lane.Classification.left_lane_boundary_id)
  return left_lane_boundary_id_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::Identifier >*
Lane_Classification::mutable_left_lane_boundary_id() {
  // @@protoc_insertion_point(field_mutable_list:osi3.Lane.Classification.left_lane_boundary_id)
  return &left_lane_boundary_id_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::Identifier >&
Lane_Classification::left_lane_boundary_id() const {
  // @@protoc_insertion_point(field_list:osi3.Lane.Classification.left_lane_boundary_id)
  return left_lane_boundary_id_;
}

// repeated .osi3.Identifier free_lane_boundary_id = 10;
int Lane_Classification::free_lane_boundary_id_size() const {
  return free_lane_boundary_id_.size();
}
void Lane_Classification::clear_free_lane_boundary_id() {
  free_lane_boundary_id_.Clear();
}
const ::osi3::Identifier& Lane_Classification::free_lane_boundary_id(int index) const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.free_lane_boundary_id)
  return free_lane_boundary_id_.Get(index);
}
::osi3::Identifier* Lane_Classification::mutable_free_lane_boundary_id(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.Lane.Classification.free_lane_boundary_id)
  return free_lane_boundary_id_.Mutable(index);
}
::osi3::Identifier* Lane_Classification::add_free_lane_boundary_id() {
  // @@protoc_insertion_point(field_add:osi3.Lane.Classification.free_lane_boundary_id)
  return free_lane_boundary_id_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::Identifier >*
Lane_Classification::mutable_free_lane_boundary_id() {
  // @@protoc_insertion_point(field_mutable_list:osi3.Lane.Classification.free_lane_boundary_id)
  return &free_lane_boundary_id_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::Identifier >&
Lane_Classification::free_lane_boundary_id() const {
  // @@protoc_insertion_point(field_list:osi3.Lane.Classification.free_lane_boundary_id)
  return free_lane_boundary_id_;
}

// optional .osi3.Lane.Classification.RoadCondition road_condition = 11;
bool Lane_Classification::has_road_condition() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void Lane_Classification::set_has_road_condition() {
  _has_bits_[0] |= 0x00000400u;
}
void Lane_Classification::clear_has_road_condition() {
  _has_bits_[0] &= ~0x00000400u;
}
void Lane_Classification::clear_road_condition() {
  if (road_condition_ != NULL) road_condition_->::osi3::Lane_Classification_RoadCondition::Clear();
  clear_has_road_condition();
}
const ::osi3::Lane_Classification_RoadCondition& Lane_Classification::road_condition() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.Classification.road_condition)
  return road_condition_ != NULL ? *road_condition_ : *default_instance_->road_condition_;
}
::osi3::Lane_Classification_RoadCondition* Lane_Classification::mutable_road_condition() {
  set_has_road_condition();
  if (road_condition_ == NULL) {
    road_condition_ = new ::osi3::Lane_Classification_RoadCondition;
  }
  // @@protoc_insertion_point(field_mutable:osi3.Lane.Classification.road_condition)
  return road_condition_;
}
::osi3::Lane_Classification_RoadCondition* Lane_Classification::release_road_condition() {
  // @@protoc_insertion_point(field_release:osi3.Lane.Classification.road_condition)
  clear_has_road_condition();
  ::osi3::Lane_Classification_RoadCondition* temp = road_condition_;
  road_condition_ = NULL;
  return temp;
}
void Lane_Classification::set_allocated_road_condition(::osi3::Lane_Classification_RoadCondition* road_condition) {
  delete road_condition_;
  road_condition_ = road_condition;
  if (road_condition) {
    set_has_road_condition();
  } else {
    clear_has_road_condition();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.Lane.Classification.road_condition)
}

// -------------------------------------------------------------------

// Lane

// optional .osi3.Identifier id = 1;
bool Lane::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Lane::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Lane::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Lane::clear_id() {
  if (id_ != NULL) id_->::osi3::Identifier::Clear();
  clear_has_id();
}
const ::osi3::Identifier& Lane::id() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
::osi3::Identifier* Lane::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.Lane.id)
  return id_;
}
::osi3::Identifier* Lane::release_id() {
  // @@protoc_insertion_point(field_release:osi3.Lane.id)
  clear_has_id();
  ::osi3::Identifier* temp = id_;
  id_ = NULL;
  return temp;
}
void Lane::set_allocated_id(::osi3::Identifier* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.Lane.id)
}

// optional .osi3.Lane.Classification classification = 2;
bool Lane::has_classification() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Lane::set_has_classification() {
  _has_bits_[0] |= 0x00000002u;
}
void Lane::clear_has_classification() {
  _has_bits_[0] &= ~0x00000002u;
}
void Lane::clear_classification() {
  if (classification_ != NULL) classification_->::osi3::Lane_Classification::Clear();
  clear_has_classification();
}
const ::osi3::Lane_Classification& Lane::classification() const {
  // @@protoc_insertion_point(field_get:osi3.Lane.classification)
  return classification_ != NULL ? *classification_ : *default_instance_->classification_;
}
::osi3::Lane_Classification* Lane::mutable_classification() {
  set_has_classification();
  if (classification_ == NULL) {
    classification_ = new ::osi3::Lane_Classification;
  }
  // @@protoc_insertion_point(field_mutable:osi3.Lane.classification)
  return classification_;
}
::osi3::Lane_Classification* Lane::release_classification() {
  // @@protoc_insertion_point(field_release:osi3.Lane.classification)
  clear_has_classification();
  ::osi3::Lane_Classification* temp = classification_;
  classification_ = NULL;
  return temp;
}
void Lane::set_allocated_classification(::osi3::Lane_Classification* classification) {
  delete classification_;
  classification_ = classification;
  if (classification) {
    set_has_classification();
  } else {
    clear_has_classification();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.Lane.classification)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaneBoundary_BoundaryPoint::kPositionFieldNumber;
const int LaneBoundary_BoundaryPoint::kWidthFieldNumber;
const int LaneBoundary_BoundaryPoint::kHeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaneBoundary_BoundaryPoint::LaneBoundary_BoundaryPoint()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.LaneBoundary.BoundaryPoint)
}

void LaneBoundary_BoundaryPoint::InitAsDefaultInstance() {
  position_ = const_cast< ::osi3::Vector3d*>(&::osi3::Vector3d::default_instance());
}

LaneBoundary_BoundaryPoint::LaneBoundary_BoundaryPoint(const LaneBoundary_BoundaryPoint& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.LaneBoundary.BoundaryPoint)
}

void LaneBoundary_BoundaryPoint::SharedCtor() {
  _cached_size_ = 0;
  position_ = NULL;
  width_ = 0;
  height_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaneBoundary_BoundaryPoint::~LaneBoundary_BoundaryPoint() {
  // @@protoc_insertion_point(destructor:osi3.LaneBoundary.BoundaryPoint)
  SharedDtor();
}

void LaneBoundary_BoundaryPoint::SharedDtor() {
  if (this != default_instance_) {
    delete position_;
  }
}

void LaneBoundary_BoundaryPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaneBoundary_BoundaryPoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaneBoundary_BoundaryPoint_descriptor_;
}

const LaneBoundary_BoundaryPoint& LaneBoundary_BoundaryPoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5flane_2eproto();
  return *default_instance_;
}

LaneBoundary_BoundaryPoint* LaneBoundary_BoundaryPoint::default_instance_ = NULL;

LaneBoundary_BoundaryPoint* LaneBoundary_BoundaryPoint::New(::google::protobuf::Arena* arena) const {
  LaneBoundary_BoundaryPoint* n = new LaneBoundary_BoundaryPoint;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LaneBoundary_BoundaryPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LaneBoundary.BoundaryPoint)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(LaneBoundary_BoundaryPoint, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<LaneBoundary_BoundaryPoint*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(width_, height_);
    if (has_position()) {
      if (position_ != NULL) position_->::osi3::Vector3d::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LaneBoundary_BoundaryPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.LaneBoundary.BoundaryPoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.Vector3d position = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_width;
        break;
      }

      // optional double width = 2;
      case 2: {
        if (tag == 17) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_height;
        break;
      }

      // optional double height = 3;
      case 3: {
        if (tag == 25) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.LaneBoundary.BoundaryPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.LaneBoundary.BoundaryPoint)
  return false;
#undef DO_
}

void LaneBoundary_BoundaryPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.LaneBoundary.BoundaryPoint)
  // optional .osi3.Vector3d position = 1;
  if (has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->position_, output);
  }

  // optional double width = 2;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->width(), output);
  }

  // optional double height = 3;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->height(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.LaneBoundary.BoundaryPoint)
}

::google::protobuf::uint8* LaneBoundary_BoundaryPoint::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.LaneBoundary.BoundaryPoint)
  // optional .osi3.Vector3d position = 1;
  if (has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->position_, false, target);
  }

  // optional double width = 2;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->width(), target);
  }

  // optional double height = 3;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->height(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.LaneBoundary.BoundaryPoint)
  return target;
}

int LaneBoundary_BoundaryPoint::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.LaneBoundary.BoundaryPoint)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .osi3.Vector3d position = 1;
    if (has_position()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->position_);
    }

    // optional double width = 2;
    if (has_width()) {
      total_size += 1 + 8;
    }

    // optional double height = 3;
    if (has_height()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaneBoundary_BoundaryPoint::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.LaneBoundary.BoundaryPoint)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LaneBoundary_BoundaryPoint* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LaneBoundary_BoundaryPoint>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.LaneBoundary.BoundaryPoint)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.LaneBoundary.BoundaryPoint)
    MergeFrom(*source);
  }
}

void LaneBoundary_BoundaryPoint::MergeFrom(const LaneBoundary_BoundaryPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.LaneBoundary.BoundaryPoint)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position()) {
      mutable_position()->::osi3::Vector3d::MergeFrom(from.position());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LaneBoundary_BoundaryPoint::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.LaneBoundary.BoundaryPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaneBoundary_BoundaryPoint::CopyFrom(const LaneBoundary_BoundaryPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LaneBoundary.BoundaryPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneBoundary_BoundaryPoint::IsInitialized() const {

  return true;
}

void LaneBoundary_BoundaryPoint::Swap(LaneBoundary_BoundaryPoint* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaneBoundary_BoundaryPoint::InternalSwap(LaneBoundary_BoundaryPoint* other) {
  std::swap(position_, other->position_);
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LaneBoundary_BoundaryPoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LaneBoundary_BoundaryPoint_descriptor_;
  metadata.reflection = LaneBoundary_BoundaryPoint_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

const ::google::protobuf::EnumDescriptor* LaneBoundary_Classification_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaneBoundary_Classification_Type_descriptor_;
}
bool LaneBoundary_Classification_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_UNKNOWN;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_OTHER;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_NO_LINE;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_SOLID_LINE;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_DASHED_LINE;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_BOTTS_DOTS;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_ROAD_EDGE;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_SNOW_EDGE;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_GRASS_EDGE;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_GRAVEL_EDGE;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_SOIL_EDGE;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_GUARD_RAIL;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_CURB;
const LaneBoundary_Classification_Type LaneBoundary_Classification::TYPE_STRUCTURE;
const LaneBoundary_Classification_Type LaneBoundary_Classification::Type_MIN;
const LaneBoundary_Classification_Type LaneBoundary_Classification::Type_MAX;
const int LaneBoundary_Classification::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* LaneBoundary_Classification_Color_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaneBoundary_Classification_Color_descriptor_;
}
bool LaneBoundary_Classification_Color_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_UNKNOWN;
const LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_OTHER;
const LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_NONE;
const LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_WHITE;
const LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_YELLOW;
const LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_RED;
const LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_BLUE;
const LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_GREEN;
const LaneBoundary_Classification_Color LaneBoundary_Classification::COLOR_VIOLET;
const LaneBoundary_Classification_Color LaneBoundary_Classification::Color_MIN;
const LaneBoundary_Classification_Color LaneBoundary_Classification::Color_MAX;
const int LaneBoundary_Classification::Color_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaneBoundary_Classification::kTypeFieldNumber;
const int LaneBoundary_Classification::kColorFieldNumber;
const int LaneBoundary_Classification::kLimitingStructureIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaneBoundary_Classification::LaneBoundary_Classification()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.LaneBoundary.Classification)
}

void LaneBoundary_Classification::InitAsDefaultInstance() {
}

LaneBoundary_Classification::LaneBoundary_Classification(const LaneBoundary_Classification& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.LaneBoundary.Classification)
}

void LaneBoundary_Classification::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  color_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaneBoundary_Classification::~LaneBoundary_Classification() {
  // @@protoc_insertion_point(destructor:osi3.LaneBoundary.Classification)
  SharedDtor();
}

void LaneBoundary_Classification::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LaneBoundary_Classification::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaneBoundary_Classification::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaneBoundary_Classification_descriptor_;
}

const LaneBoundary_Classification& LaneBoundary_Classification::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5flane_2eproto();
  return *default_instance_;
}

LaneBoundary_Classification* LaneBoundary_Classification::default_instance_ = NULL;

LaneBoundary_Classification* LaneBoundary_Classification::New(::google::protobuf::Arena* arena) const {
  LaneBoundary_Classification* n = new LaneBoundary_Classification;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LaneBoundary_Classification::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LaneBoundary.Classification)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(LaneBoundary_Classification, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<LaneBoundary_Classification*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(type_, color_);

#undef ZR_HELPER_
#undef ZR_

  limiting_structure_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LaneBoundary_Classification::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.LaneBoundary.Classification)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.LaneBoundary.Classification.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::osi3::LaneBoundary_Classification_Type_IsValid(value)) {
            set_type(static_cast< ::osi3::LaneBoundary_Classification_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_color;
        break;
      }

      // optional .osi3.LaneBoundary.Classification.Color color = 2;
      case 2: {
        if (tag == 16) {
         parse_color:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::osi3::LaneBoundary_Classification_Color_IsValid(value)) {
            set_color(static_cast< ::osi3::LaneBoundary_Classification_Color >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_limiting_structure_id;
        break;
      }

      // repeated .osi3.Identifier limiting_structure_id = 3;
      case 3: {
        if (tag == 26) {
         parse_limiting_structure_id:
          DO_(input->IncrementRecursionDepth());
         parse_loop_limiting_structure_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_limiting_structure_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_limiting_structure_id;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.LaneBoundary.Classification)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.LaneBoundary.Classification)
  return false;
#undef DO_
}

void LaneBoundary_Classification::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.LaneBoundary.Classification)
  // optional .osi3.LaneBoundary.Classification.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .osi3.LaneBoundary.Classification.Color color = 2;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->color(), output);
  }

  // repeated .osi3.Identifier limiting_structure_id = 3;
  for (unsigned int i = 0, n = this->limiting_structure_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->limiting_structure_id(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.LaneBoundary.Classification)
}

::google::protobuf::uint8* LaneBoundary_Classification::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.LaneBoundary.Classification)
  // optional .osi3.LaneBoundary.Classification.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .osi3.LaneBoundary.Classification.Color color = 2;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->color(), target);
  }

  // repeated .osi3.Identifier limiting_structure_id = 3;
  for (unsigned int i = 0, n = this->limiting_structure_id_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->limiting_structure_id(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.LaneBoundary.Classification)
  return target;
}

int LaneBoundary_Classification::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.LaneBoundary.Classification)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .osi3.LaneBoundary.Classification.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .osi3.LaneBoundary.Classification.Color color = 2;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->color());
    }

  }
  // repeated .osi3.Identifier limiting_structure_id = 3;
  total_size += 1 * this->limiting_structure_id_size();
  for (int i = 0; i < this->limiting_structure_id_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->limiting_structure_id(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaneBoundary_Classification::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.LaneBoundary.Classification)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LaneBoundary_Classification* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LaneBoundary_Classification>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.LaneBoundary.Classification)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.LaneBoundary.Classification)
    MergeFrom(*source);
  }
}

void LaneBoundary_Classification::MergeFrom(const LaneBoundary_Classification& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.LaneBoundary.Classification)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  limiting_structure_id_.MergeFrom(from.limiting_structure_id_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LaneBoundary_Classification::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.LaneBoundary.Classification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaneBoundary_Classification::CopyFrom(const LaneBoundary_Classification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LaneBoundary.Classification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneBoundary_Classification::IsInitialized() const {

  return true;
}

void LaneBoundary_Classification::Swap(LaneBoundary_Classification* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaneBoundary_Classification::InternalSwap(LaneBoundary_Classification* other) {
  std::swap(type_, other->type_);
  std::swap(color_, other->color_);
  limiting_structure_id_.UnsafeArenaSwap(&other->limiting_structure_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LaneBoundary_Classification::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LaneBoundary_Classification_descriptor_;
  metadata.reflection = LaneBoundary_Classification_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LaneBoundary::kIdFieldNumber;
const int LaneBoundary::kBoundaryLineFieldNumber;
const int LaneBoundary::kClassificationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LaneBoundary::LaneBoundary()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:osi3.LaneBoundary)
}

void LaneBoundary::InitAsDefaultInstance() {
  id_ = const_cast< ::osi3::Identifier*>(&::osi3::Identifier::default_instance());
  classification_ = const_cast< ::osi3::LaneBoundary_Classification*>(&::osi3::LaneBoundary_Classification::default_instance());
}

LaneBoundary::LaneBoundary(const LaneBoundary& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:osi3.LaneBoundary)
}

void LaneBoundary::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  classification_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LaneBoundary::~LaneBoundary() {
  // @@protoc_insertion_point(destructor:osi3.LaneBoundary)
  SharedDtor();
}

void LaneBoundary::SharedDtor() {
  if (this != default_instance_) {
    delete id_;
    delete classification_;
  }
}

void LaneBoundary::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LaneBoundary::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LaneBoundary_descriptor_;
}

const LaneBoundary& LaneBoundary::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_osi_5flane_2eproto();
  return *default_instance_;
}

LaneBoundary* LaneBoundary::default_instance_ = NULL;

LaneBoundary* LaneBoundary::New(::google::protobuf::Arena* arena) const {
  LaneBoundary* n = new LaneBoundary;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LaneBoundary::Clear() {
// @@protoc_insertion_point(message_clear_start:osi3.LaneBoundary)
  if (_has_bits_[0 / 32] & 5u) {
    if (has_id()) {
      if (id_ != NULL) id_->::osi3::Identifier::Clear();
    }
    if (has_classification()) {
      if (classification_ != NULL) classification_->::osi3::LaneBoundary_Classification::Clear();
    }
  }
  boundary_line_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LaneBoundary::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:osi3.LaneBoundary)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .osi3.Identifier id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_boundary_line;
        break;
      }

      // repeated .osi3.LaneBoundary.BoundaryPoint boundary_line = 2;
      case 2: {
        if (tag == 18) {
         parse_boundary_line:
          DO_(input->IncrementRecursionDepth());
         parse_loop_boundary_line:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_boundary_line()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_boundary_line;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(26)) goto parse_classification;
        break;
      }

      // optional .osi3.LaneBoundary.Classification classification = 3;
      case 3: {
        if (tag == 26) {
         parse_classification:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_classification()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:osi3.LaneBoundary)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:osi3.LaneBoundary)
  return false;
#undef DO_
}

void LaneBoundary::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:osi3.LaneBoundary)
  // optional .osi3.Identifier id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->id_, output);
  }

  // repeated .osi3.LaneBoundary.BoundaryPoint boundary_line = 2;
  for (unsigned int i = 0, n = this->boundary_line_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->boundary_line(i), output);
  }

  // optional .osi3.LaneBoundary.Classification classification = 3;
  if (has_classification()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->classification_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:osi3.LaneBoundary)
}

::google::protobuf::uint8* LaneBoundary::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:osi3.LaneBoundary)
  // optional .osi3.Identifier id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->id_, false, target);
  }

  // repeated .osi3.LaneBoundary.BoundaryPoint boundary_line = 2;
  for (unsigned int i = 0, n = this->boundary_line_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->boundary_line(i), false, target);
  }

  // optional .osi3.LaneBoundary.Classification classification = 3;
  if (has_classification()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->classification_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:osi3.LaneBoundary)
  return target;
}

int LaneBoundary::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:osi3.LaneBoundary)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 5u) {
    // optional .osi3.Identifier id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->id_);
    }

    // optional .osi3.LaneBoundary.Classification classification = 3;
    if (has_classification()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->classification_);
    }

  }
  // repeated .osi3.LaneBoundary.BoundaryPoint boundary_line = 2;
  total_size += 1 * this->boundary_line_size();
  for (int i = 0; i < this->boundary_line_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->boundary_line(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LaneBoundary::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:osi3.LaneBoundary)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LaneBoundary* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LaneBoundary>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:osi3.LaneBoundary)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:osi3.LaneBoundary)
    MergeFrom(*source);
  }
}

void LaneBoundary::MergeFrom(const LaneBoundary& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:osi3.LaneBoundary)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  boundary_line_.MergeFrom(from.boundary_line_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::osi3::Identifier::MergeFrom(from.id());
    }
    if (from.has_classification()) {
      mutable_classification()->::osi3::LaneBoundary_Classification::MergeFrom(from.classification());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LaneBoundary::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:osi3.LaneBoundary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LaneBoundary::CopyFrom(const LaneBoundary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:osi3.LaneBoundary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LaneBoundary::IsInitialized() const {

  return true;
}

void LaneBoundary::Swap(LaneBoundary* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LaneBoundary::InternalSwap(LaneBoundary* other) {
  std::swap(id_, other->id_);
  boundary_line_.UnsafeArenaSwap(&other->boundary_line_);
  std::swap(classification_, other->classification_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LaneBoundary::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LaneBoundary_descriptor_;
  metadata.reflection = LaneBoundary_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LaneBoundary_BoundaryPoint

// optional .osi3.Vector3d position = 1;
bool LaneBoundary_BoundaryPoint::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LaneBoundary_BoundaryPoint::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
void LaneBoundary_BoundaryPoint::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
void LaneBoundary_BoundaryPoint::clear_position() {
  if (position_ != NULL) position_->::osi3::Vector3d::Clear();
  clear_has_position();
}
const ::osi3::Vector3d& LaneBoundary_BoundaryPoint::position() const {
  // @@protoc_insertion_point(field_get:osi3.LaneBoundary.BoundaryPoint.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
::osi3::Vector3d* LaneBoundary_BoundaryPoint::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::osi3::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LaneBoundary.BoundaryPoint.position)
  return position_;
}
::osi3::Vector3d* LaneBoundary_BoundaryPoint::release_position() {
  // @@protoc_insertion_point(field_release:osi3.LaneBoundary.BoundaryPoint.position)
  clear_has_position();
  ::osi3::Vector3d* temp = position_;
  position_ = NULL;
  return temp;
}
void LaneBoundary_BoundaryPoint::set_allocated_position(::osi3::Vector3d* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.LaneBoundary.BoundaryPoint.position)
}

// optional double width = 2;
bool LaneBoundary_BoundaryPoint::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LaneBoundary_BoundaryPoint::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
void LaneBoundary_BoundaryPoint::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
void LaneBoundary_BoundaryPoint::clear_width() {
  width_ = 0;
  clear_has_width();
}
 double LaneBoundary_BoundaryPoint::width() const {
  // @@protoc_insertion_point(field_get:osi3.LaneBoundary.BoundaryPoint.width)
  return width_;
}
 void LaneBoundary_BoundaryPoint::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:osi3.LaneBoundary.BoundaryPoint.width)
}

// optional double height = 3;
bool LaneBoundary_BoundaryPoint::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void LaneBoundary_BoundaryPoint::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
void LaneBoundary_BoundaryPoint::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
void LaneBoundary_BoundaryPoint::clear_height() {
  height_ = 0;
  clear_has_height();
}
 double LaneBoundary_BoundaryPoint::height() const {
  // @@protoc_insertion_point(field_get:osi3.LaneBoundary.BoundaryPoint.height)
  return height_;
}
 void LaneBoundary_BoundaryPoint::set_height(double value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:osi3.LaneBoundary.BoundaryPoint.height)
}

// -------------------------------------------------------------------

// LaneBoundary_Classification

// optional .osi3.LaneBoundary.Classification.Type type = 1;
bool LaneBoundary_Classification::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LaneBoundary_Classification::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void LaneBoundary_Classification::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void LaneBoundary_Classification::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::osi3::LaneBoundary_Classification_Type LaneBoundary_Classification::type() const {
  // @@protoc_insertion_point(field_get:osi3.LaneBoundary.Classification.type)
  return static_cast< ::osi3::LaneBoundary_Classification_Type >(type_);
}
 void LaneBoundary_Classification::set_type(::osi3::LaneBoundary_Classification_Type value) {
  assert(::osi3::LaneBoundary_Classification_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:osi3.LaneBoundary.Classification.type)
}

// optional .osi3.LaneBoundary.Classification.Color color = 2;
bool LaneBoundary_Classification::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LaneBoundary_Classification::set_has_color() {
  _has_bits_[0] |= 0x00000002u;
}
void LaneBoundary_Classification::clear_has_color() {
  _has_bits_[0] &= ~0x00000002u;
}
void LaneBoundary_Classification::clear_color() {
  color_ = 0;
  clear_has_color();
}
 ::osi3::LaneBoundary_Classification_Color LaneBoundary_Classification::color() const {
  // @@protoc_insertion_point(field_get:osi3.LaneBoundary.Classification.color)
  return static_cast< ::osi3::LaneBoundary_Classification_Color >(color_);
}
 void LaneBoundary_Classification::set_color(::osi3::LaneBoundary_Classification_Color value) {
  assert(::osi3::LaneBoundary_Classification_Color_IsValid(value));
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:osi3.LaneBoundary.Classification.color)
}

// repeated .osi3.Identifier limiting_structure_id = 3;
int LaneBoundary_Classification::limiting_structure_id_size() const {
  return limiting_structure_id_.size();
}
void LaneBoundary_Classification::clear_limiting_structure_id() {
  limiting_structure_id_.Clear();
}
const ::osi3::Identifier& LaneBoundary_Classification::limiting_structure_id(int index) const {
  // @@protoc_insertion_point(field_get:osi3.LaneBoundary.Classification.limiting_structure_id)
  return limiting_structure_id_.Get(index);
}
::osi3::Identifier* LaneBoundary_Classification::mutable_limiting_structure_id(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.LaneBoundary.Classification.limiting_structure_id)
  return limiting_structure_id_.Mutable(index);
}
::osi3::Identifier* LaneBoundary_Classification::add_limiting_structure_id() {
  // @@protoc_insertion_point(field_add:osi3.LaneBoundary.Classification.limiting_structure_id)
  return limiting_structure_id_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::Identifier >*
LaneBoundary_Classification::mutable_limiting_structure_id() {
  // @@protoc_insertion_point(field_mutable_list:osi3.LaneBoundary.Classification.limiting_structure_id)
  return &limiting_structure_id_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::Identifier >&
LaneBoundary_Classification::limiting_structure_id() const {
  // @@protoc_insertion_point(field_list:osi3.LaneBoundary.Classification.limiting_structure_id)
  return limiting_structure_id_;
}

// -------------------------------------------------------------------

// LaneBoundary

// optional .osi3.Identifier id = 1;
bool LaneBoundary::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LaneBoundary::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void LaneBoundary::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void LaneBoundary::clear_id() {
  if (id_ != NULL) id_->::osi3::Identifier::Clear();
  clear_has_id();
}
const ::osi3::Identifier& LaneBoundary::id() const {
  // @@protoc_insertion_point(field_get:osi3.LaneBoundary.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
::osi3::Identifier* LaneBoundary::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::osi3::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LaneBoundary.id)
  return id_;
}
::osi3::Identifier* LaneBoundary::release_id() {
  // @@protoc_insertion_point(field_release:osi3.LaneBoundary.id)
  clear_has_id();
  ::osi3::Identifier* temp = id_;
  id_ = NULL;
  return temp;
}
void LaneBoundary::set_allocated_id(::osi3::Identifier* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.LaneBoundary.id)
}

// repeated .osi3.LaneBoundary.BoundaryPoint boundary_line = 2;
int LaneBoundary::boundary_line_size() const {
  return boundary_line_.size();
}
void LaneBoundary::clear_boundary_line() {
  boundary_line_.Clear();
}
const ::osi3::LaneBoundary_BoundaryPoint& LaneBoundary::boundary_line(int index) const {
  // @@protoc_insertion_point(field_get:osi3.LaneBoundary.boundary_line)
  return boundary_line_.Get(index);
}
::osi3::LaneBoundary_BoundaryPoint* LaneBoundary::mutable_boundary_line(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.LaneBoundary.boundary_line)
  return boundary_line_.Mutable(index);
}
::osi3::LaneBoundary_BoundaryPoint* LaneBoundary::add_boundary_line() {
  // @@protoc_insertion_point(field_add:osi3.LaneBoundary.boundary_line)
  return boundary_line_.Add();
}
::google::protobuf::RepeatedPtrField< ::osi3::LaneBoundary_BoundaryPoint >*
LaneBoundary::mutable_boundary_line() {
  // @@protoc_insertion_point(field_mutable_list:osi3.LaneBoundary.boundary_line)
  return &boundary_line_;
}
const ::google::protobuf::RepeatedPtrField< ::osi3::LaneBoundary_BoundaryPoint >&
LaneBoundary::boundary_line() const {
  // @@protoc_insertion_point(field_list:osi3.LaneBoundary.boundary_line)
  return boundary_line_;
}

// optional .osi3.LaneBoundary.Classification classification = 3;
bool LaneBoundary::has_classification() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void LaneBoundary::set_has_classification() {
  _has_bits_[0] |= 0x00000004u;
}
void LaneBoundary::clear_has_classification() {
  _has_bits_[0] &= ~0x00000004u;
}
void LaneBoundary::clear_classification() {
  if (classification_ != NULL) classification_->::osi3::LaneBoundary_Classification::Clear();
  clear_has_classification();
}
const ::osi3::LaneBoundary_Classification& LaneBoundary::classification() const {
  // @@protoc_insertion_point(field_get:osi3.LaneBoundary.classification)
  return classification_ != NULL ? *classification_ : *default_instance_->classification_;
}
::osi3::LaneBoundary_Classification* LaneBoundary::mutable_classification() {
  set_has_classification();
  if (classification_ == NULL) {
    classification_ = new ::osi3::LaneBoundary_Classification;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LaneBoundary.classification)
  return classification_;
}
::osi3::LaneBoundary_Classification* LaneBoundary::release_classification() {
  // @@protoc_insertion_point(field_release:osi3.LaneBoundary.classification)
  clear_has_classification();
  ::osi3::LaneBoundary_Classification* temp = classification_;
  classification_ = NULL;
  return temp;
}
void LaneBoundary::set_allocated_classification(::osi3::LaneBoundary_Classification* classification) {
  delete classification_;
  classification_ = classification;
  if (classification) {
    set_has_classification();
  } else {
    clear_has_classification();
  }
  // @@protoc_insertion_point(field_set_allocated:osi3.LaneBoundary.classification)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace osi3

// @@protoc_insertion_point(global_scope)
